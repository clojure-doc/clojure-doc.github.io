<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Clojure Guides: Basic Web Development</title>
    

<meta name="description" content="This guide covers building a simple web-application using common
Clojure libraries. When you&#39;re done working through it, you&#39;ll have a
little webapp that displays some (x, y) locations from a database,
letting you add more locations as well.It&#39;s assumed that you&#39;re already somewhat familiar with Clojure. If
not, see the Getting Started and
Introduction guides.">

<meta property="og:description" content="This guide covers building a simple web-application using common
Clojure libraries. When you&#39;re done working through it, you&#39;ll have a
little webapp that displays some (x, y) locations from a database,
letting you add more locations as well.It&#39;s assumed that you&#39;re already somewhat familiar with Clojure. If
not, see the Getting Started and
Introduction guides.">

<meta property="og:url" content="https://clojure-doc.org/articles/tutorials/basic_web_development/" />
<meta property="og:title" content="Basic Web Development" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://clojure-doc.org/articles/tutorials/basic_web_development/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Clojure Guides</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li ><a href="/">Home</a></li>
                <li><a href="https://github.com/clojure-doc/clojure-doc.github.io">Contribute</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div><!--/.container-fluid -->
</nav>


<div class="container">


    <div class="row">
        <div class="col-lg-9">
            <div id="content">
                
<div id="custom-page">
    <div id="page-header">
        <h2>Basic Web Development</h2>
    </div>
    
    <p>This guide covers building a simple web-application using common
Clojure libraries. When you're done working through it, you'll have a
little webapp that displays some (x, y) locations from a database,
letting you add more locations as well.</p><p>It's assumed that you're already somewhat familiar with Clojure. If
not, see the <a href="/articles/tutorials/getting_started/">Getting Started</a> and
<a href="/articles/tutorials/introduction/">Introduction</a> guides.</p><p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/3.0/">Creative Commons
Attribution 3.0 Unported License</a> (including images &amp;
stylesheets). The source is available <a href="https://github.com/clojure-doc/clojure-doc.github.io">on
Github</a>.</p><p>This guide uses Clojure 1.11.1, as well as current versions of the
component libraries noted below.</p><h2 id="conceptual-overview-of-components">Conceptual Overview of Components</h2><p>We'll use four major components (briefly described below) for our
little webapp:</p><ul><li>Ring</li><li>Compojure</li><li>Hiccup</li><li>H2</li></ul><h3 id="ring">Ring</h3><p><a href="https://github.com/ring-clojure/ring">Ring</a> (<a href="https://clojars.org/ring">at
clojars</a>) is a foundational Clojure web
application library. It:</p><ul><li>sets things up such that an HTTP request comes into your webapp
as a regular Clojure hashmap, and likewise makes it so that you
can return a response as a hashmap.</li><li>provides <a href="https://github.com/ring-clojure/ring/blob/master/SPEC">a
spec</a>
describing exactly what those request and response maps should
look like.</li><li>brings along a web server
(<a href="http://www.eclipse.org/jetty/">Jetty</a>) and connects your
webapp to it.</li></ul><p>For this tutorial, we won't actually need to deal with these maps
by-hand, as you'll soon see.</p><p>For more info, see:</p><ul><li><a href="https://github.com/ring-clojure/ring#readme">the Ring readme</a></li><li><a href="https://github.com/ring-clojure/ring/wiki">its wiki docs</a></li><li><a href="https://ring-clojure.github.io/ring/">its API docs</a></li></ul><h3 id="compojure">Compojure</h3><p>If we were using only Ring, we'd have to write one single function to
take that incoming request map and then delegate to various functions
depending upon which page was requested.
<a href="https://github.com/weavejester/compojure">Compojure</a> (<a href="https://clojars.org/compojure">at
clojars</a>) provides some handy features
to take care of this for us such that we can associate url paths with
corresponding functions, all in one place.</p><p>For more info, see:</p><ul><li><a href="https://github.com/weavejester/compojure#readme">the Compojure readme</a></li><li><a href="https://github.com/weavejester/compojure/wiki">its wiki docs</a></li><li><a href="https://weavejester.github.io/compojure/">its API docs</a></li></ul><h3 id="hiccup">Hiccup</h3><p><a href="https://github.com/weavejester/hiccup">Hiccup</a> (<a href="https://clojars.org/hiccup">at
clojars</a>) provides a quick and easy way to
generate html. It converts regular Clojure data structures right into
html. For example,</p><pre><code class="clojure">[:p "Hello, " [:i "doctor"] " Jones."]
</code></pre><p>becomes</p><pre><code class="html">&lt;p&gt;Hello, &lt;i&gt;doctor&lt;/i&gt; Jones.&lt;/p&gt;
</code></pre><p>but it also does two extra handy bits of magic:</p><ul><li><p>it provides some CSS-like shortcuts for specifying id and class,
and</p></li><li><p>it automatically unpacks seqs for you, for example:</p><pre><code class="clojure">[:p '("a" "b" "c")]
;; expands to (and so, is the same as if you wrote)
[:p "a" "b" "c"]
</code></pre></li></ul><p>For more info, see:</p><ul><li><a href="https://github.com/weavejester/hiccup#readme">the Hiccup readme</a></li><li><a href="https://github.com/weavejester/hiccup/wiki">its wiki docs</a></li><li><a href="https://weavejester.github.io/hiccup/">its API docs</a></li></ul><h3 id="h2">H2</h3><p><a href="http://www.h2database.com/html/main.html">H2</a> is a small and fast Java SQL
database that could be embedded in your application or run in server
mode. It uses a single file for storage, but also could be run as in-memory DB.</p><blockquote><p>Another similar Java-based embedded DB that could be used in your
application is <a href="http://db.apache.org/derby/">Apache Derby</a>.</p></blockquote><h2 id="create-and-set-up-your-project">Create and set up your project</h2><p>We're going to create this project from scratch and use the Clojure CLI
so you can how see how all the moving parts work.</p><p>In a new folder, perhaps called <code>my-webapp</code>, we're going to create a <code>deps.edn</code>
file to specify the libraries we want to use, and a couple of folders: one
for CSS files and one for your source code.</p><p>The <code>deps.edn</code> file should have the following contents:</p><pre><code class="clojure">{:paths ["src" "resources"]
 :deps {;; basic Ring and web server:
        ring/ring-core {:mvn/version "1.9.6"}
        ring/ring-jetty-adapter {:mvn/version "1.9.6"}

        ;; routing:
        compojure/compojure {:mvn/version "1.7.0"}

        ;; convenient package of "default" middleware:
        ring/ring-defaults {:mvn/version "0.3.4"}

        ;; to generate HTML:
        hiccup/hiccup {:mvn/version "1.0.5"}

        ;; for the database:
        com.github.seancorfield/next.jdbc {:mvn/version "1.3.862"}
        com.h2database/h2 {:mvn/version "2.1.214"}}}
</code></pre><p>Now we'll create the first version of our source file:</p><pre><code class="clojure">;; this file is: src/my_app/handler.clj
(ns my-webapp.handler
  (:require [compojure.core :refer [defroutes GET]]
            [compojure.route :as route]
            [ring.adapter.jetty :as jetty]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults]]))

(defroutes app-routes
  (GET "/" [] "Hello World")
  (route/not-found "Not Found"))

(def app
  (wrap-defaults #'app-routes site-defaults))

(defn -main []
  (jetty/run-jetty #'app {:port 3000}))
</code></pre><blockquote><p>Note: the directory has an underscore in it (<code>my_webapp</code>) but the namespace has a hyphen in it (<code>my-webapp</code>). This is important in Clojure: we use lowercase names with hyphens to separate "words" -- often called kebab-case -- but the corresponding directory and filenames should be lowercase with underscores to separate "words" -- often called snake-case. This is due to how Clojure maps code onto names that are acceptable to the underlying JVM ecosystem.</p></blockquote><p>At this point you can run this very basic web application from the command-line:</p><pre><code class="bash">clojure -M -m my-webapp.handler
</code></pre><p>This says we want to run Clojure's main entry point (<code>-M</code>) and then <code>-m my-webapp.handler</code>
tells Clojure that we want it to run the <code>-main</code> function in that namespace.</p><p>It will output something like this (and then "hang" while the web server is running):</p><pre><code>2023-03-24 14:03:21.305:INFO::main: Logging initialized @2337ms to org.eclipse.jetty.util.log.StdErrLog
2023-03-24 14:03:21.752:INFO:oejs.Server:main: jetty-9.4.48.v20220622; built: 2022-06-21T20:42:25.880Z; git: 6b67c5719d1f4371b33655ff2d047d24e171e49a; jvm 19.0.2+7
2023-03-24 14:03:21.783:INFO:oejs.AbstractConnector:main: Started ServerConnector@43201f84{HTTP/1.1, (http/1.1)}{0.0.0.0:3000}
2023-03-24 14:03:21.783:INFO:oejs.Server:main: Started @2815ms
</code></pre><blockquote><p>Note: you can stop this program running by pressing <code>^C</code> (control-c) on macOS or Linux, or by pressing <code>^Z</code> (control-z) on Windows.</p></blockquote><p>The only relevant line in that output is <code>Started ServerConnector</code> where it
shows the host and port it is running on -- <code>0.0.0.0:3000</code> -- so you should
be able to output a web browser and go to http://localhost:3000 and you should
see:</p><pre><code>Hello World
</code></pre><p>If you go to http://localhost:3000/page you should instead see:</p><pre><code>Not Found
</code></pre><p>This is because <code>defroutes</code> specifies a single route (<code>GET "/"</code>) and then
<code>route/not-found</code> will match all other requests and present the given string
<code>"Not Found"</code>.</p><p>Stop the program (as indicated above) and we'll add more features to it.</p><h2 id="add-some-styling">Add some styling</h2><p>Now we're going to create some styling by creating a CSS file:</p><pre><code class="bash">mkdir -p resources/public/css
touch resources/public/css/styles.css
</code></pre><p>and put into that file something like:</p><pre><code class="css">body {
    background-color: Cornsilk;
}

#header-links {
    background-color: BurlyWood;
    padding: 10px;
}

h1 {
    color: CornflowerBlue;
}
</code></pre><h2 id="set-up-your-database">Set up your database</h2><p>A file containing the database would be automatically created when you connect to it for the
first time, so all necessary database preparations could be done programmatically
using the REPL (with help of <code>next.jdbc</code>):</p><pre><code class="bash">clj
</code></pre><p>Execute the following code to create a new my-webapp.h2.db database file in db
subdirectory of your project, create a table we'll use for our webapp, and add
one record to start us off with:</p><pre><code class="clojure">user=&gt; (require '[next.jdbc :as jdbc] '[next.jdbc.sql :as sql])
nil
;; a hash map that describes the database we plan to use:
user=&gt; (def db-spec {:dbtype "h2" :dbname "./my-db"})
#'user/db-spec
;; execute a single statement to create the locations table:
user=&gt; (jdbc/execute-one! db-spec ["
CREATE TABLE locations (
  id bigint primary key auto_increment,
  x  integer,
  y  integer
)
"])
#:next.jdbc{:update-count 0}
;; insert a single row of data into that table:
user=&gt; (sql/insert! db-spec :locations {:x 8 :y 9})
#:LOCATIONS{:ID 1} ; the generated key(s) from the insert
user=&gt;
</code></pre><p>and press <code>ctrl-d</code> to exit.</p><p>You'll see that a file called <code>my-db.mv.db</code> has been created: this contains your <code>my-db</code> database.</p><blockquote><p>Note: the <code>#:namespace{:key value}</code> notation is shorthand for <code>{:namespace/key value}</code> and is something you'll see a lot in Clojure. Namespace-qualified keys provide additional context: in the first case above <code>:next.jdbc/update-count</code> is produced by <code>next.jdbc</code> itself whereas <code>:LOCATIONS.ID</code> indicates the table and column name of the auto-increment key from the database.</p></blockquote><p>For more about how to use the database functions, see the
<a href="https://cljdoc.org/d/com.github.seancorfield/next.jdbc/1.3.862/doc/getting-started">Getting Started with next.jdbc</a>.</p><h2 id="create-some-db-access-functions">Create some db access functions</h2><p>We're going to work bottom-up, so that our code is always in a state
where we can evaluate it and try it out via the REPL (hopefully, via
your REPL-connected editor).</p><p>Create a <code>src/my_webapp/db.clj</code> file and make it look like:</p><pre><code class="clojure">;; src/my_app/db.clj
(ns my-webapp.db
  (:require [next.jdbc.sql :as sql]))

(def db-spec {:dbtype "h2" :dbname "./my-db"})

(defn add-location-to-db
  [x y]
  (let [results (sql/insert! db-spec :locations {:x x :y y})]
    (assert (and (map? results) (:LOCATIONS/ID results)))
    results))

(defn get-xy
  [loc-id]
  (let [results (sql/query db-spec
                           ["select x, y from locations where id = ?" loc-id])]
    (assert (= (count results) 1))
    (first results)))

(defn get-all-locations
  []
  (sql/query db-spec ["select id, x, y from locations"]))

(comment
  (get-all-locations)
  ;; =&gt; [#:LOCATIONS{:ID 1, :X 8, :Y 9}]
  (get-xy 1)
  ;; =&gt; #:LOCATIONS{:X 8, :Y 9}
  )
</code></pre><p>Note that <code>sql/query</code> returns a vector  of maps. Each map
entry's key is a column name (as a Clojure keyword), and its value is
the value for that column.</p><p>You can try the code out in the <code>comment</code> form by evaluating the expressions
in -- and you should see the same results as the inline comments show.</p><p>You can also try those calls yourself in a standalone REPL,
if you like:</p><pre><code class="clojure">clj
Clojure 1.11.1
user=&gt; (require 'my-webapp.db)
nil
;; you must require a namespace before you go into it:
user=&gt; (in-ns 'my-webapp.db)
#object[clojure.lang.Namespace 0x707865bd "my-webapp.db"]
;; sql/query returns a vector:
my-webapp.db=&gt; (sql/query db-spec
                 ["select x, y from locations where id = ?" 1])
[#:LOCATIONS{:X 8, :Y 9}]
;; the get-xy function only returns a single hash map:
my-webapp.db=&gt; (get-xy 1)
#:LOCATIONS{:X 8, :Y 9}
my-webapp.db=&gt;
</code></pre><h2 id="create-your-views">Create your Views</h2><p>Next, we will create the views -- that generate our HTML pages.</p><p>Create a <code>src/my_webapp/views.clj</code> file and make it look like:</p><pre><code class="clojure">;; src/my_webapp/views.clj
(ns my-webapp.views
  (:require [hiccup.page :as page]
            [my-webapp.db :as db]
            [ring.util.anti-forgery :as util]))

(defn gen-page-head
  [title]
  [:head
   [:title (str "Locations: " title)]
   (page/include-css "/css/styles.css")])

(def header-links
  [:div#header-links
   "[ "
   [:a {:href "/"} "Home"]
   " | "
   [:a {:href "/add-location"} "Add a Location"]
   " | "
   [:a {:href "/all-locations"} "View All Locations"]
   " ]"])

(defn home-page
  []
  (page/html5
   (gen-page-head "Home")
   header-links
   [:h1 "Home"]
   [:p "Webapp to store and display some 2D (x,y) locations."]))

(defn add-location-page
  []
  (page/html5
   (gen-page-head "Add a Location")
   header-links
   [:h1 "Add a Location"]
   [:form {:action "/add-location" :method "POST"}
    (util/anti-forgery-field) ; prevents cross-site scripting attacks
    [:p "x value: " [:input {:type "text" :name "x"}]]
    [:p "y value: " [:input {:type "text" :name "y"}]]
    [:p [:input {:type "submit" :value "submit location"}]]]))

(defn add-location-results-page
  [{:keys [x y]}]
  (let [{id :LOCATIONS/ID} (db/add-location-to-db x y)]
    (page/html5
     (gen-page-head "Added a Location")
     header-links
     [:h1 "Added a Location"]
     [:p "Added [" x ", " y "] (id: " id ") to the db. "
      [:a {:href (str "/location/" id)} "See for yourself"]
      "."])))

(defn location-page
  [loc-id]
  (let [{x :LOCATIONS/X y :LOCATIONS/Y} (db/get-xy loc-id)]
    (page/html5
     (gen-page-head (str "Location " loc-id))
     header-links
     [:h1 "A Single Location"]
     [:p "id: " loc-id]
     [:p "x: " x]
     [:p "y: " y])))

(defn all-locations-page
  []
  (let [all-locs (db/get-all-locations)]
    (page/html5
     (gen-page-head "All Locations in the db")
     header-links
     [:h1 "All Locations"]
     [:table
      [:tr [:th "id"] [:th "x"] [:th "y"]]
      (for [loc all-locs]
        [:tr
         [:td (:LOCATIONS/ID loc)]
         [:td (:LOCATIONS/X loc)]
         [:td (:LOCATIONS/Y loc)]])])))
</code></pre><p>These functions generate all the HTML pages needed by our application.</p><p>Each of the functions with names ending in "-page"
(which will be the ones being called from <code>handler.clj</code> in the next section)
is returning just a string consisting of HTML markup.
Compojure will take care of placing that into a response
hashmap for us.</p><p>We use the <code>{sym :key}</code> form of destructuring in several functions to
give local symbol names to the values associated with the database table/column keys.</p><h2 id="set-up-your-routes">Set up your routes</h2><p>Finally, we're going to add the extra routes we need into the main file
of our application, so that they call our new view functions.</p><p>In the basic <code>src/my_webapp/handler.clj</code> file you've created, we
specify our webapp's <em>routes</em> inside the <code>defroutes</code> macro. That is,
we assign a function to handle each of the url paths we'd like to
support, and then at the end provide a "not found" page for any other
url paths.</p><p>Make your <code>handler.clj</code> file look like this:</p><pre><code class="clojure">;; src/my_app/handler.clj
(ns my-webapp.handler
  (:require [compojure.core :refer [defroutes GET POST]] ; add POST here
            [compojure.route :as route]
            [my-webapp.views :as views] ; add this require
            [ring.adapter.jetty :as jetty]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults]]))

(defroutes app-routes ; replace the previous app-routes with this
  (GET "/"
    []
    (views/home-page))
  (GET "/add-location"
    []
    (views/add-location-page))
  (POST "/add-location"
    {params :params}
    (views/add-location-results-page params))
  (GET "/location/:loc-id"
    [loc-id]
    (views/location-page loc-id))
  (GET "/all-locations"
    []
    (views/all-locations-page))
  (route/resources "/")
  (route/not-found "Not Found"))

(def app
  (wrap-defaults #'app-routes site-defaults))

(defn -main []
  (jetty/run-jetty #'app {:port 3000}))
</code></pre><p>Each of those expressions in <code>defroutes</code> like <code>(GET ...)</code> or <code>(POST ...)</code> are
so-called "routes". They each evaluate to a function that
takes a Ring request hashmap and returns a response hashmap. Your
<code>views/foo</code> function's job is to return that response hashmap, but note
that Compojure is kind enough to make a suitable response map out of
any HTML you return.</p><p>Incidentally, note the special destructuring that Compojure does for
you in each of those routes. It can pull out url query (and body)
parameters, as well as pieces of the url path requested, and hand them
to your views functions. Read more about that at <a href="https://github.com/weavejester/compojure/wiki/Destructuring-Syntax">Compojure
destructuring</a>.</p><h2 id="run-your-webapp-during-development">Run your webapp during development</h2><p>You can run your webapp any time via <code>clojure -M -m my-webapp.handler</code> as
shown above. Once it is running, visit http://localhost:3000 in your
browser.</p><p>You should be able to stop the webapp by
hitting <code>ctrl-c</code>.</p><h2 id="deploy-your-webapp">Deploy your webapp</h2><p>For the final step, we're going to build an "uberjar". This is a file that
contains your code plus the Clojure runtime plus all the libraries your
code depends on: it's a single, self-contained file that can be executed
by <code>java</code> alone and can easily be deployed to servers or services to put
your application on the web.</p><p>In order to produce this <code>.jar</code> file, we will rely on the official
<code>tools.build</code> library, and add a <code>build.clj</code> file.</p><p>All of the steps will be shown here but you can read the
<a href="https://clojure.org/guides/tools_build"><code>tools.build</code> guide</a> for more details.</p><p>To make your webapp suitable for deployment, make the following
changes:</p><h3 id="changes-in-depsedn">Changes in deps.edn</h3><p>In your <code>dep.edn</code> file add the following, after the <code>:deps</code> hash map:</p><pre><code class="clojure"> :aliases
 {;; Run with clj -T:build function-in-build
  :build {:deps {io.github.clojure/tools.build {:git/tag "v0.9.4" :git/sha "76b78fe"}}
          :ns-default build}}
</code></pre><p>The whole <code>deps.edn</code> file should now look like this:</p><pre><code class="clojure">{:paths ["src" "resources"]
 :deps {;; basic Ring and web server:
        ring/ring-core {:mvn/version "1.9.6"}
        ring/ring-jetty-adapter {:mvn/version "1.9.6"}

        ;; routing:
        compojure/compojure {:mvn/version "1.7.0"}

        ;; convenient package of "default" middleware:
        ring/ring-defaults {:mvn/version "0.3.4"}

        ;; to generate HTML:
        hiccup/hiccup {:mvn/version "1.0.5"}

        ;; for the database:
        com.github.seancorfield/next.jdbc {:mvn/version "1.3.862"}
        com.h2database/h2 {:mvn/version "2.1.214"}}
 :aliases
 {;; Run with clj -T:build function-in-build
  :build {:deps {io.github.clojure/tools.build {:git/tag "v0.9.4" :git/sha "76b78fe"}}
          :ns-default build}}}
</code></pre><h3 id="add-a-buildclj-file">Add a build.clj file</h3><p>The <code>tools.build</code> library is intended to be used with a <code>build.clj</code> script
which typically lives in the root of your project and is invoked via the
<code>:build</code> alias in your project. It is a Clojure namespace, containing any number
of function that you can invoke using <code>clojure -T:build</code> and the function name.</p><p>The <code>:ns-default</code> key in the <code>:build</code> alias is typically set to <code>build</code> so
that you can say <code>clojure -T:build foo</code> and the CLI will treat that as an
invocation of the function <code>build/foo</code>. All such functions take a single
argument, which is a hash map of arguments supplied on the command-line
using Clojure-style syntax:</p><pre><code class="clojure">clojure -T:build foo :bar 42
;; invokes (build/foo {:bar 42})
</code></pre><p>For the purposes of this web application project, you want a single function
that can build the "uberjar" you need. This is typically called <code>uber</code> so
here is the <code>build.clj</code> file you need to add, alongside <code>deps.edn</code> at the
top-level of your project:</p><pre><code class="clojure">(ns build
  (:require [clojure.tools.build.api :as b]))

;; the main namespace in your application:
(def main-ns 'my-webapp.handler)
;; where to compile your application:
(def class-dir "target/classes")
;; where to create the uberjar file:
(def uber-file "target/my-webapp.jar")

;; "basis" is a description of your project, as data, that includes
;; details about the paths and dependencies (libraries) it uses:
(def basis (b/create-basis {:project "deps.edn"}))

(defn clean [_]
  (b/delete {:path "target"}))

(defn uber [_]
  (clean nil)
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/compile-clj {:basis basis
                  :src-dirs ["src"]
                  :class-dir class-dir})
  (b/uber {:class-dir class-dir
           :uber-file uber-file
           :basis basis
           :main main-ns}))
</code></pre><h3 id="changes-in-handlerclj">Changes in handler.clj</h3><p>In order to make it easier to invoke your application as an uberjar,
we are going to make a couple of small changes.</p><p>First, we're going to add <code>(:gen-class)</code> to the end of the <code>ns</code> form at the
top of the file so it looks like this:</p><pre><code class="clojure">(ns my-webapp.handler
  (:require [compojure.core :refer [defroutes GET POST]] ; add POST here
            [compojure.route :as route]
            [my-webapp.views :as views] ; add this require
            [ring.adapter.jetty :as jetty]
            [ring.middleware.defaults :refer [site-defaults wrap-defaults]])
  (:gen-class))
</code></pre><p>This tells Clojure to generate a JVM-compatible class for your main namespace
so that the <code>-main</code> function can be invoked directly from Java instead of
going through <code>clojure.main</code> as we've done so far with the Clojure CLI
and the <code>-M -m my-webapp.handler</code> options.</p><p>Second, we're going to update the <code>-main</code> function so that you can specify
the port on which to run the web application, so it isn't fixed to be <code>3000</code>.
We'll allow the port to specified either on the command-line, or as an
environment variable, else default to a specific value (<code>3000</code>).</p><pre><code class="clojure">(defn -main [&amp; [port]]
  ;; command-line arguments and environment variables are always
  ;; strings so we need to call parse-long on the result; which
  ;; means that if neither are specified and we provide the default,
  ;; then it has to be a string as well:
  (let [port (parse-long (or port
                             (System/getenv "PORT")
                             "3000"))]
    (jetty/run-jetty #'app {:port port})))
</code></pre><h3 id="build-and-run-it">Build and Run it</h3><p>Now create an uberjar of your webapp:</p><pre><code>clojure -T:build uber
</code></pre><p>And now you can run it directly:</p><pre><code>java -jar target/my-webapp.jar 8080
</code></pre><p>(or on whatever port number you wish). If you run the JAR file from another
folder, remember to copy the <code>my-db.mv.db</code> file to that folder!</p><p>You could also run it like this:</p><pre><code>PORT=8000 java -jar target/my-webapp.jar
</code></pre><h2 id="see-also">See Also</h2><ul><li>To get a head start with a more "batteries-included" project
template, see <a href="http://www.luminusweb.net/">Luminus</a>.</li></ul><h2 id="contributors">Contributors</h2><p>John Gabriele <a href="mailto:jmg3000@gmail.com">jmg3000@gmail.com</a> (original author)</p><p>Ivan Kryvoruchko <a href="mailto:gildraug@gmail.com">gildraug@gmail.com</a></p><p>Sean Corfield <a href="mailto:sean@corfield.org">sean@corfield.org</a></p>

    <div id="prev-next">
        
        <a href="/articles/tutorials/editors/">&laquo; Clojure Editors</a>
        
        
        ||
        
        
        <a href="/articles/tutorials/parsing_xml_with_zippers/">Parsing XML in Clojure &raquo;</a>
        
    </div>
</div>

            </div>
        </div>

        <div class="col-md-3">
            <div id="sidebar">
                <h3>Links</h3>
                <ul id="links">
                    
                    <li><a href="/articles/about/">About</a></li>
                    
                    <li><a href="/articles/content/">Table of Contents</a></li>
                    
                    <li><a href="/articles/ecosystem/community/">Clojure Community</a></li>
                    
                    <li><a href="/articles/tutorials/getting_started/">Getting Started with Clojure</a></li>
                    
                    <li><a href="/articles/tutorials/introduction/">Introduction to Clojure</a></li>
                    
                    <li><a href="/articles/tutorials/editors/">Clojure Editors</a></li>
                    
                    <li><a href="/articles/tutorials/basic_web_development/">Basic Web Development</a></li>
                    
                    <li><a href="/articles/tutorials/parsing_xml_with_zippers/">Parsing XML in Clojure</a></li>
                    
                    <li><a href="/articles/tutorials/growing_a_dsl_with_clojure/">Growing a DSL with Clojure</a></li>
                    
                    <li><a href="/articles/ecosystem/web_development/">Web Development (Overview)</a></li>
                    
                    <li><a href="/articles/cookbooks/data_structures/">Data Structures (Help wanted)</a></li>
                    
                    <li><a href="/articles/cookbooks/strings/">Strings</a></li>
                    
                    <li><a href="/articles/cookbooks/math/">Mathematics with Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/date_and_time/">Date and Time (Help wanted)</a></li>
                    
                    <li><a href="/articles/cookbooks/files_and_directories/">Working with Files and Directories in Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/middleware/">Middleware in Clojure</a></li>
                    
                </ul>
                
                
            </div>
        </div>
    </div>
    <footer>Copyright &copy; 2023 Multiple Authors
        <p style="text-align: center;">Powered by <a href="https://cryogenweb.org">Cryogen</a></p></footer>
</div>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js" type="application/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>


</body>
</html>
