<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Clojure Guides: Language: Collections and Sequences</title>
    

<meta name="description" content="This guide covers:">

<meta property="og:description" content="This guide covers:">

<meta property="og:url" content="https://clojure-doc.org/articles/language/collections_and_sequences/" />
<meta property="og:title" content="Language: Collections and Sequences" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://clojure-doc.org/articles/language/collections_and_sequences/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Clojure Guides</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li ><a href="/">Home</a></li>
                <li><a href="https://github.com/clojure-doc/clojure-doc.github.io">Contribute</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div><!--/.container-fluid -->
</nav>


<div class="container">


    <div class="row">
        <div class="col-lg-9">
            <div id="content">
                
<div id="custom-page">
    <div id="page-header">
        <h2>Language: Collections and Sequences</h2>
    </div>
    
    <p>This guide covers:</p><ul><li>Collections in Clojure</li><li>Sequences in Clojure</li><li>Core collection types</li><li>Key operations on collections and sequences</li><li>Other topics related to collections and sequences</li></ul><p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>
(including images &amp; stylesheets). The source is available <a href="https://github.com/clojure-doc/clojure-doc.github.io">on Github</a>.</p><h2 id="what-version-of-clojure-does-this-guide-cover">What Version of Clojure Does This Guide Cover?</h2><p>This guide covers Clojure 1.11.</p><h2 id="overview">Overview</h2><p>Clojure provides a number of powerful abstractions including <em>collections</em> and <em>sequences</em>.
When working with Clojure,
many operations are expressed as a series of operations on collections or sequences.</p><p>Most of Clojure's core library treats collections and sequences the same way, although
sometimes a distinction has to be made (e.g. with lazy infinite sequences).</p><p><code>clojure.core</code> provides many fundamental operations on collections, such as:
<code>map</code>, <code>filter</code>, <code>remove</code>, <code>take</code>, and <code>drop</code>.
Basic operations on collections and sequences can be combined to implement
more complex operations.</p><h3 id="clojure-collections-are-immutable-persistent">Clojure Collections are Immutable (Persistent)</h3><p>Clojure collections are <em>immutable</em> (<em>persistent</em>). The term "persistent data structures" has
nothing to do with durably storing them on disk. What it means is that collections are
mutated (updated) by producing new collections. To quote Wikipedia:</p><blockquote><p>In computing, a persistent data structure is a data structure that always preserves
the previous version of itself when it is modified. Such data structures are effectively
immutable, as their operations do not (visibly) update the structure in-place, but instead
always yield a new updated structure.</p></blockquote><p>Clojure's persistent data structures are implemented as trees and <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie"><em>tries</em></a> and
typically have O(log<sub>32</sub> <em>n</em>) access complexity where <em>n</em> is the number of elements.</p><h2 id="the-collection-abstraction">The Collection Abstraction</h2><p>Clojure has a collection abstraction with several key operations supported for
all collection implementations. They are</p><ul><li><code>=</code>: checks value equality of a collection compared to other collections</li><li><code>count</code>: returns number of elements in a collection</li><li><code>conj</code>: adds an item to a collection in the most efficient way</li><li><code>empty</code>: returns an empty collection of the same type as the argument</li><li><code>seq</code>: gets a sequence of a collection</li></ul><p>Collections satisfy the <code>coll?</code> predicate.</p><p>These functions work on all core Clojure collection types.</p><h2 id="core-collection-types">Core Collection Types</h2><p>Clojure has several core collection types:</p><ul><li>Maps (called hashes or dictionaries in some other languages)</li><li>Vectors</li><li>Lists</li><li>Sets</li></ul><h3 id="maps">Maps</h3><p>Maps associate keys with values. Both keys and values can be of any type, but
keys must be comparable. There are several implementations of maps with
different guarantees about ordering but the general hash map in Clojure is
unordered.
Hash maps are typically instantiated with literals:</p><pre><code class="clojure">{:language "Clojure" :creator "Rich Hickey"}
</code></pre><p>Commas can be used in map literals (Clojure compiler treats the comma as whitespace):</p><pre><code class="clojure">{:language "Clojure", :creator "Rich Hickey"}
</code></pre><p><code>clojure.core/sorted-map</code> and <code>clojure.core/array-map</code> produce ordered maps:</p><pre><code class="klipse-clojure nohighlight">(sorted-map :language "Clojure" :creator "Rich Hickey")
;; ⇒ {:creator "Rich Hickey", :language "Clojure"}
</code></pre><pre><code class="klipse-clojure nohighlight">(array-map :language "Clojure" :creator "Rich Hickey")
;; ⇒ {:language "Clojure", :creator "Rich Hickey"}
</code></pre><p>Unsurprisingly, map literals must contain an even number of forms (as many keys as values). Otherwise
the code will not compile:</p><pre><code class="klipse-clojure nohighlight">{:language "Clojure" :creator}
</code></pre><p>In general, the only major difference between Clojure maps and maps/hashes/dictionaries in some other languages
is that Clojure maps are <em>immutable</em>. When a Clojure map is modified, the result is a new map that internally
has structural sharing (for efficiency reasons) but semantically is a separate immutable value.</p><p>You can <code>conj</code> a key/value pair into a map:</p><pre><code class="klipse-clojure nohighlight">(conj {:language "Clojure"} [:creator "Rich Hickey"])
;; ⇒ {:creator "Rich Hickey", :language "Clojure"}
</code></pre><p>Maps can be iterated over in their "natural order" so they are <code>seqable?</code>
-- you can call <code>seq</code> on them -- but they are not <code>sequential?</code> as they have
no guaranteed order. You can get
a sequence of keys by calling <code>keys</code> or a sequence of values by calling <code>vals</code>
on the map, and the order of those sequences will be consistent with each other and also
with the order of key/value pairs you get by calling <code>seq</code> on the same map.
Maps are also <code>associative?</code> and <code>counted?</code>.</p><p>See also the <a href="https://clojure.org/guides/learn/hashed_colls#_maps">official Clojure guide for maps</a> on clojure.org.</p><h4 id="maps-as-functions">Maps As Functions</h4><p>Maps in Clojure can be used as functions on their keys. See the <a href="/articles/language/functions/#maps-as-functions">Functions guide</a>
for more information.</p><h4 id="keywords-as-functions">Keywords As Functions</h4><p>Keywords in Clojure can be used as functions on maps. See the <a href="/articles/language/functions/#keywords-as-functions">Functions guide</a>
for more information.</p><h3 id="vectors">Vectors</h3><p>Vectors are collections that offer efficient random access (by index). They are typically instantiated with
literals:</p><pre><code class="clojure">[1 2 3 4]

["clojure" "scala" "erlang" "f#" "haskell" "ocaml"]
</code></pre><p>Commas can be used to separate vector elements (Clojure compiler treats
the comma as whitespace):</p><pre><code class="clojure">["clojure", "scala", "erlang", "f#", "haskell", "ocaml"]
</code></pre><p>Unlike lists, vectors are not used for function invocation. They are, however, used to make certain
forms (e.g. the list of locals in <code>let</code> or parameters in <code>defn</code>) stand out visually. This was
an intentional decision in Clojure design.</p><p>You can <code>conj</code> a value into a vector and it will be appended:</p><pre><code class="klipse-clojure nohighlight">(conj [1 2 3 4] 5)
;; ⇒ [1 2 3 4 5]
</code></pre><p>Vectors are both <code>seqable?</code> and <code>sequential?</code> as their natural order is based
on the indices into the vector. Vectors are <code>associative?</code> and <code>counted?</code>.
Vectors are associative on their indices:</p><pre><code class="klipse-clojure nohighlight">(get [1 2 3 4] 2)
;; =&gt; 3
</code></pre><pre><code class="klipse-clojure nohighlight">(assoc [1 2 3 4] 2 :three)
;; ⇒ [1 2 :three 4]
</code></pre><p>See also the <a href="https://clojure.org/guides/learn/sequential_colls#_vectors">official Clojure guide for vectors</a> on clojure.org.</p><h3 id="lists">Lists</h3><p>Lists in Clojure are singly linked lists. Access or modifications of list head is efficient, random access
is not.</p><p>Lists in Clojure are special because they represent code forms, from function calls to macro calls to special forms.
Code is data in Clojure and it is represented primarily as lists:</p><pre><code class="klipse-clojure nohighlight">(empty? [])
</code></pre><p>First item on the list is said to be in the <em>calling position</em>.</p><p>When used as "just" data structures, lists are typically instantiated with literals with quoting:</p><pre><code class="klipse-clojure nohighlight">'(1 2 3 4)
</code></pre><pre><code class="klipse-clojure nohighlight">'("clojure" "scala" "erlang" "f#" "haskell" "ocaml")
</code></pre><p>Or you can explicitly use the <code>list</code> form:</p><pre><code class="klipse-clojure nohighlight">(list 1 2 3 4)
;; ⇒ (1 2 3 4)
</code></pre><p>Commas can be used to separate list elements (Clojure compiler treats
the comma as whitespace):</p><pre><code class="klipse-clojure nohighlight">'("clojure", "scala", "erlang", "f#", "haskell", "ocaml")
</code></pre><p>You can <code>conj</code> a value into a list and it will be prepended:</p><pre><code class="klipse-clojure nohighlight">(conj '(1 2 3 4) 5)
;; ⇒ (5 1 2 3 4)
</code></pre><p>Lists are both <code>seqable?</code> and <code>sequential?</code> but not all lists are <code>counted?</code>:
lazily constructed lists, such as <code>(cons 1 (list 1 2 3 4))</code>, are not <code>counted?</code>
because they do not have a known length until they are fully realized. You
can still call <code>count</code> on such lists (as long as they are not infinite!) but
that will cause the entire list to be realized.</p><p>See also the <a href="https://clojure.org/guides/learn/sequential_colls#_lists">official Clojure guide for lists</a> on clojure.org.</p><h4 id="lists-and-metaprogramming-in-clojure">Lists and Metaprogramming in Clojure</h4><p>Metaprogramming in Clojure (and other Lisp dialects) is different from metaprogramming in, say, Ruby, because
in Ruby metaprogramming is <em>primarily</em> about producing strings while in Clojure it is about producing
<em>data structures</em> (mostly <em>lists</em>). For sophisticated DSLs, producing data structures directly lets
developers avoid a lot of incidental complexity that string generation brings along.</p><p>This topic is covered in detail in the <a href="/articles/language/macros/">Macros and Metaprogramming</a>.</p><h3 id="sets">Sets</h3><p>Sets are collections that offer efficient membership check operation and only allow each element to appear in the collection
once. They are typically instantiated with literals:</p><pre><code class="klipse-clojure nohighlight">#{1 2 3 4}
</code></pre><pre><code class="klipse-clojure nohighlight">#{"clojure" "scala" "erlang" "f#" "haskell" "ocaml"}
</code></pre><p>Commas can be used to separate set elements (Clojure compiler treats the as whitespace):</p><pre><code class="klipse-clojure nohighlight">#{"clojure", "scala", "erlang", "f#", "haskell", "ocaml"}
</code></pre><p>You can <code>conj</code> a value into a set:</p><pre><code class="klipse-clojure nohighlight">(conj #{:tea :coffee} :juice)
;; ⇒ #{:coffee :tea :juice}
</code></pre><p>Like maps, sets are <code>seqable?</code> but not <code>sequential?</code> because they have no
guaranteed order. You can call <code>seq</code> on a set to get a sequence of its elements
in "natural order" (based on the hash of the elements, essentially).
Sets are <code>counted?</code> but they are not <code>associative?</code> (they support lookup by
their elements but have no associated values for those "keys").</p><p>See also the <a href="https://clojure.org/guides/learn/hashed_colls#_sets">official Clojure guide for sets</a> on clojure.org.</p><h4 id="sets-as-functions">Sets As Functions</h4><p>Sets in Clojure can be used as functions on their elements. See the <a href="/articles/language/functions/#sets-as-functions">Functions guide</a>
for more information.</p><h4 id="set-membership-checks">Set Membership Checks</h4><p>The most common way of checking if an element is in a set is by using set as a function:</p><pre><code class="klipse-clojure nohighlight">(#{1 2 3 4} 1)
;; ⇒ 1
</code></pre><pre><code class="klipse-clojure nohighlight">(#{1 2 3 4} 10)
;; ⇒ nil
</code></pre><pre><code class="klipse-clojure nohighlight">(if (#{1 2 3 4} 1)
  :hit
  :miss)
;; ⇒ :hit
</code></pre><h2 id="sequences">Sequences</h2><p>The sequence abstraction represents a sequential view of a collection or collection-like
entity (computation result).</p><p><code>clojure.core/seq</code> is a function that produces a sequence over the given argument.
Data types that <code>clojure.core/seq</code> can produce a sequence over are called <em>seqable</em>:</p><ul><li>Clojure collections</li><li>Java maps</li><li>All iterable types (types that implement <code>java.util.Iterable</code>)</li><li>Java collections (<code>java.util.Set</code>, <code>java.util.List</code>, etc)</li><li>Java arrays</li><li>All types that implement <code>java.lang.CharSequence</code> interface, including Java strings</li><li>All types that implement <code>clojure.lang.Seqable</code> interface</li><li>nil</li></ul><p>The sequence abstraction supports several operations:</p><ul><li><code>first</code></li><li><code>rest</code></li><li><code>next</code></li></ul><p>and there are two ways to produce a sequence:</p><ul><li><code>seq</code> produces a sequence over its argument (often a collection)</li><li><code>lazy-seq</code> creates a <em>lazy sequence</em> (that is produced by performing computation)</li></ul><h3 id="seq-cons-list">seq, cons, list*</h3><p><code>clojure.core/seq</code> takes a single argument and returns a sequential view over it:</p><pre><code class="klipse-clojure nohighlight">(seq [1 2 3])
;; ⇒ (1 2 3)
</code></pre><p>When given an empty collection or sequence, <code>clojure.core/seq</code> returns nil:</p><pre><code class="klipse-clojure nohighlight">(seq [])
;; ⇒ nil
</code></pre><p>this is commonly used in the following pattern:</p><pre><code class="klipse-clojure nohighlight">(def xs [1 2 3])
(if (seq xs)
  (println "Do something with this sequence")
  (println "Do something else"))
</code></pre><p>Another function that constructs sequences is <code>clojure.core/cons</code>. It prepends values to the head of
the given sequence:</p><pre><code class="klipse-clojure nohighlight">(cons 0 (range 1 3))
;; ⇒ (0 1 2)
</code></pre><p><code>clojure.core/list*</code> does the same for a number of values:</p><pre><code class="klipse-clojure nohighlight">(list* 0 1 (range 2 5))
;; ⇒ (0 1 2 3 4)
</code></pre><p><code>clojure.core/cons</code> and <code>clojure.core/list*</code> are primarily used to produce lazy sequences and in metaprogramming (when writing
macros). As far as metaprogramming goes, sequences and lists are the same and it is common to
add items in the beginning of the list (into the <em>calling position</em>).</p><p>Note that <code>clojure.core/cons</code> does not create "cons cells" and lists in Clojure are not implemented
as linked "cons cells" (like in many other dialects of Lisp).</p><h3 id="first-rest-next">first, rest, next</h3><p><code>clojure.core/first</code> returns the first item in the sequence. <code>clojure.core/next</code> and <code>clojure.core/rest</code>
return the sequence without the first element:</p><pre><code class="klipse-clojure nohighlight">(first (seq [1 2 3 4 5 6]))
;; ⇒ 1

(rest (seq [1 2 3 4 5 6]))
;; ⇒ (2 3 4 5 6)

(next (seq [1 2 3 4 5 6]))
;; ⇒ (2 3 4 5 6)
</code></pre><p>The difference between them is what they return on a single element sequence:</p><pre><code class="klipse-clojure nohighlight">(rest (seq [:one]))
;; ⇒ ()
</code></pre><pre><code class="klipse-clojure nohighlight">(next (seq [:one]))
;; ⇒ nil
</code></pre><p>Note that all three functions implicitly call <code>seq</code> on their argument so you
can omit the explicit call:</p><pre><code class="klipse-clojure nohighlight">(first [1 2 3 4 5 6])
;; ⇒ 1

(rest [1 2 3 4 5 6])
;; ⇒ (2 3 4 5 6)

(next [1 2 3 4 5 6])
;; ⇒ (2 3 4 5 6)
</code></pre><h3 id="lazy-sequences-in-clojure">Lazy Sequences in Clojure</h3><p><em>Lazy sequences</em> are produced by performing computation or I/O. They can be infinite
or not have exact length (e.g. a sequence of all powers of 2 or an audio stream).</p><p>Lazy sequences is an broad topic and covered in the <a href="/articles/language/laziness/">Laziness</a> guide.</p><h2 id="key-operations-on-collections-and-sequences">Key Operations on Collections and Sequences</h2><p>Below is an overview of <code>clojure.core</code> functions that work on collections and sequences. Most of them
work the same way for all types of collections, however, there are exception to this rule. For example,
functions like <code>clojure.core/assoc</code>, <code>clojure.core/dissoc</code> and <code>clojure.core/get-in</code> only really
make sense in the context of maps and other associative data structures (for example, records).</p><p><code>clojure.core/conj</code> adds elements to a collection in the most efficient manner, which depends on
collection implementation details and won't be the same for vectors and lists.</p><p>In general, Clojure design emphasizes that operations on collections and sequences should be uniform and
follow the principle of least surprise. In real world projects, however, the difference between
algorithmic complexity and other runtime characteristics of various collection types often cannot
be ignored. Keep this in mind.</p><p>You can find more information in the <a href="/articles/language/core_overview/">clojure.core Overview</a> and <a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a>.</p><h3 id="count">count</h3><p>Returns a count of the number of items in a collection. An argument of nil returns 0.</p><pre><code class="klipse-clojure nohighlight">(count "Hello")
;; ⇒ 5
</code></pre><pre><code class="klipse-clojure nohighlight">(count [1 2 3 4 5 6 7])
;; ⇒ 7
</code></pre><pre><code class="klipse-clojure nohighlight">(count nil)
;; ⇒ 0
</code></pre><p>Note that count does not return in constant time for all collections. This can be determined with <code>counted?</code>.
Keep in mind that lazy sequences must be realized to get a count of the items. This is often not intended and
can cause a variety of otherwise cryptic errors.</p><pre><code class="klipse-clojure nohighlight">(counted? "Hello")
;; ⇒ false
</code></pre><p>(even tho' Clojure strings are Java <code>String</code>s and have a known length without iteration)</p><pre><code class="klipse-clojure nohighlight">;; will be fully realized when using (count (range 10))
(counted? (range 10))
;; ⇒ true
</code></pre><p>(a range with an upper bound knows its length without iteration)</p><pre><code class="klipse-clojure nohighlight">;; (range) is an infinite sequence
(counted? (range))
;; ⇒ false
</code></pre><p>(an unbounded range has no known length)</p><pre><code class="klipse-clojure nohighlight">;; Constant time return of (count)
(counted? [1 2 3 4 5])
;; ⇒ true
</code></pre><h3 id="conj">conj</h3><p><code>conj</code> is short for "conjoin". As the name implies, <code>conj</code> takes a collection and argument(s) and returns the collection with those arguments added.</p><p>Adding items to a collection occurs at different places depending on the concrete type of collection.</p><p>List addition occurs at the beginning of the list. This is because accessing the head of the list is a constant time operation, and accessing
the tail requires traversal of the entire list.</p><pre><code class="klipse-clojure nohighlight">(conj '(1 2) 3)
;; ⇒ (3 1 2)
</code></pre><p>Vectors have constant time access across the entire data structure. <code>conj</code> appends to the end of a vector.</p><pre><code class="klipse-clojure nohighlight">(conj [1 2] 3)
;; ⇒ [1 2 3]
</code></pre><p>Maps do not have guaranteed ordering, so the location that items are added is irrelevant. <code>conj</code> requires vectors of [key value] pairs to be
added to the map.</p><pre><code class="klipse-clojure nohighlight">(conj {:a 1 :b 2 :c 3} [:d 4])
;; ⇒ {:d 4, :a 1, :c 3, :b 2}
</code></pre><pre><code class="klipse-clojure nohighlight">(conj {:cats 1 :dogs 2} [:ants 400] [:giraffes 13])
;; ⇒ {:giraffes 13, :ants 400, :cats 1, :dogs 2}
</code></pre><p>Sets also do not have guaranteed ordering. <code>conj</code> returns a set with the item added. As the concept of sets implies, added items will not duplicate equivalent items if they are present in the set.</p><pre><code class="klipse-clojure nohighlight">(conj #{1 4} 5)
;; ⇒ #{1 4 5}
</code></pre><pre><code class="klipse-clojure nohighlight">(conj #{:a :b :c} :b :c :d :e)
;; ⇒ #{:a :c :b :d :e}
</code></pre><h3 id="get">get</h3><p><code>get</code> returns the value for the specified key in a map or record, for the
index of a vector or for the value in a set. If the key is not present,
<code>get</code> returns nil or a supplied default value.</p><pre><code class="klipse-clojure nohighlight">;; val of a key in a map
(get {:a 1 :b 2 :c 3} :b)
;; ⇒ 2
</code></pre><pre><code class="klipse-clojure nohighlight">;; index of a vector
(get [10 15 20 25] 2)
;; ⇒ 20
</code></pre><pre><code class="klipse-clojure nohighlight">;; in a set, returns the value itself if present
(get #{1 10 100 2 20 200} 1)
;; ⇒ 1

```klipse-clojure
;; returns nil if key is not present
(get {:a 1 :b 2} :c)
;; ⇒ nil
</code></pre><pre><code class="klipse-clojure nohighlight">;; vector does not have an _index_ of 4. nil is returned
(get [1 2 3 4] 4)
;; ⇒ nil
</code></pre><pre><code class="klipse-clojure nohighlight">(defrecord Hand [index middle ring pinky thumb])
(get (Hand. 3 4 3.5 2 2) :index)
;; ⇒ 3
</code></pre><p><code>get</code> also supports a default return value supplied as the last argument.</p><pre><code class="klipse-clojure nohighlight">;; index 4 does not exist. return default value
(get [1 2 3 4] 4 "Not Found")
;; ⇒ "Not Found"
</code></pre><pre><code class="klipse-clojure nohighlight">;; key :c does not exist, so return default value of 3
(get {:a 1 :b 2} :c 3)
;; ⇒ 3
</code></pre><h3 id="assoc">assoc</h3><p><code>assoc</code> takes a collection, a key, and a value and returns a collection of the same type as the supplied collection with the key mapped to the new value.</p><p><code>assoc</code> is similar to <code>get</code> in how it works with maps, records or vectors. When applied to a map or record, the same type is returned with the key/value pairs added or modified.  When applied to a vector, a vector is returned with the key acting as an index and the index being replaced by the value.</p><p>Since maps and records can not contain multiple equivalent keys, supplying <code>assoc</code> with a key/value that exists in the one will cause <code>assoc</code> to return modify the key at that value in the result and not duplicate the key.</p><pre><code class="klipse-clojure nohighlight">(assoc {:a 1} :b 2)
;; ⇒ {:b 2, :a 1}
</code></pre><pre><code class="klipse-clojure nohighlight">(assoc {:a 1 :b 45 :c 3} :b 2)
;; ⇒ {:a 1, :c 3, :b 2}
</code></pre><pre><code class="klipse-clojure nohighlight">(defrecord Hand [index middle ring pinky thumb])
(assoc (Hand. 3 4 3.5 2 2) :index 3.75)
;; ⇒ #user.Hand{:index 3.75, :middle 4, :ring 3.5, :pinky 2, :thumb 2}
</code></pre><p>When using <code>assoc</code> with a vector, the key is the index and the value is the value to assign to that index in the returned vector.
The key must be &lt;= (count vector) or an index out of bounds error will occur.</p><pre><code class="klipse-clojure nohighlight">(assoc [1 2 76] 2 3) ; ⇒ [1 2 3]
</code></pre><pre><code class="klipse-clojure nohighlight">;; index 5 does not exist. valid indexes for this vector are: 0, 1, 2
(assoc [1 2 3] 5 6)
;; the error here is slightly different in Clojure/Script
</code></pre><p>When the key is equal to <code>(count vector)</code>, <code>assoc</code> will add an item to the
end of the vector.</p><pre><code class="klipse-clojure nohighlight">(assoc [1 2 3] 3 4) ; ⇒ [1 2 3 4]
</code></pre><h3 id="dissoc">dissoc</h3><p><code>dissoc</code> returns a map with the supplied keys, and subsequently their values, removed. Unlike <code>assoc</code>, <code>dissoc</code> does not work on vectors. When a record is provided, <code>dissoc</code> returns a map. For similar functionality with vectors, see <code>subvec</code> and <code>concat</code>.</p><pre><code class="klipse-clojure nohighlight">(dissoc {:a 1 :b 2 :c 3} :b)
;; ⇒ {:a 1, :c 3}
</code></pre><pre><code class="klipse-clojure nohighlight">(dissoc {:a 1 :b 14 :c 390 :d 75 :e 2 :f 51} :b :c :e)
;; ⇒ {:a 1, :f 51, :d 75}
</code></pre><pre><code class="klipse-clojure nohighlight">;; note that a map is returned, not a record.
(defrecord Hand [index middle ring pinky thumb])
;; always be careful with the bandsaw!
(dissoc (Hand. 3 4 3.5 2 2) :ring)
;; ⇒ {:index 3, :middle 4, :pinky 2, :thumb 2}
</code></pre><h3 id="first">first</h3><p><code>first</code> returns the first item in the collection. <code>first</code> returns nil if the argument is empty or is nil.</p><p>Note that for collections that do not guarantee order like some maps and sets, the behaviour of <code>first</code> should not be relied on.</p><pre><code class="klipse-clojure nohighlight">(first (range 10))
;; ⇒ 0
</code></pre><pre><code class="klipse-clojure nohighlight">(first [:floor :piano :seagull])
;; ⇒ :floor
</code></pre><pre><code class="klipse-clojure nohighlight">(first [])
;; ⇒ nil
</code></pre><h3 id="rest">rest</h3><p><code>rest</code> returns a seq of items starting with the second element in the collection. <code>rest</code> returns an empty seq if the collection only contains a single item.</p><p><code>rest</code> should also not be relied on when using maps and sets unless you are sure ordering is guaranteed (or you don't care about ordering at all).</p><pre><code class="klipse-clojure nohighlight">(rest [13 1 16 -4])
;; ⇒ (1 16 -4)
</code></pre><pre><code class="klipse-clojure nohighlight">(rest '(:french-fry))
;; ⇒ '()
</code></pre><p>The behaviour of <code>rest</code> should be contrasted with <code>next</code>. <code>next</code> returns <code>nil</code> if the collection only has a single item. This is important when considering "truthiness" of values since an empty seq is still a truthy value but <code>nil</code> is not.</p><pre><code class="klipse-clojure nohighlight">(if (rest '("stuff"))
  (println "Does this print?"))
;; yes, it prints.
</code></pre><pre><code class="clojure">;; NEVER FINISHES EXECUTION!!!
;; "done" is never reached because (rest x) is always a "true" value
(defn inf
  [x]
  (if (rest x)
    (inf (rest x))
    "done"))
</code></pre><h3 id="empty">empty?</h3><p><code>empty?</code> returns true if the collection has no items, or false if it has 1 or more items.</p><pre><code class="klipse-clojure nohighlight">(empty? [])
;; ⇒ true
</code></pre><pre><code class="klipse-clojure nohighlight">(empty? '(1 2 3))
;; ⇒ false
</code></pre><p>Do not confuse <code>empty?</code> with <code>empty</code>. This can be a source of great confusion:</p><pre><code class="klipse-clojure nohighlight">(if (empty [1 2 3]) ;; empty returns an empty seq, which is true! use empty? here.
  "It's empty"
  "It's not empty")
;; ⇒ "It's empty"
</code></pre><h3 id="empty-1">empty</h3><p><code>empty</code> returns an empty collection of the same type as the collection provided.</p><pre><code class="klipse-clojure nohighlight">(empty [1 2 3])
;; ⇒ []
</code></pre><pre><code class="klipse-clojure nohighlight">(empty {:a 1 :b 2 :c 3})
;; ⇒ {}
</code></pre><h3 id="not-empty">not-empty</h3><p><code>not-empty</code> returns nil if the collection has no items. If the collection contains items, the collection is returned.</p><pre><code class="klipse-clojure nohighlight">(not-empty '(:mice :elephants :children))
;; ⇒ (:mice :elephants :children)
</code></pre><pre><code class="klipse-clojure nohighlight">(not-empty '())
;; ⇒ nil
</code></pre><h3 id="contains">contains?</h3><p><code>contains</code> returns true if the provided <em>key</em> is present in a collection. <code>contains</code> is similar to <code>get</code> in that vectors treat the key as an index. <code>contains</code> will always return false for lists.</p><pre><code class="klipse-clojure nohighlight">(contains? {:a 1 :b 2 :c 3} :c)
;; ⇒ true
</code></pre><pre><code class="klipse-clojure nohighlight">;; true if index 2 exists
(contains? ["John" "Mary" "Paul"] 2)
;; ⇒ true
</code></pre><pre><code class="klipse-clojure nohighlight">;; false if index 5 does not exist
(contains? ["John" "Mary" "Paul"] 5)
;; ⇒ false
</code></pre><pre><code class="klipse-clojure nohighlight">;; "Paul" does not exist as an index
(contains? ["John" "Mary" "Paul"] "Paul")
;; ⇒ false
</code></pre><pre><code class="klipse-clojure nohighlight">;; lists are not supported. contains? won't traverse a collection for a result.
(contains? '(1 2 3) 0)
;; ⇒ java.lang.IllegalArgumentException: contains? not supported on type: clojure.lang.PersistentList
;; =&gt; ClojureScript produces false here
</code></pre><p>(in Clojure, this throws an exception; in ClojureScript, it produces <code>false</code>)</p><h3 id="some">some</h3><p><code>some</code> will apply a predicate to each value in a collection until a non-false/nil result is returned then immediately return that result.</p><pre><code class="klipse-clojure nohighlight">(some even? [1 2 3 4 5])
;; ⇒ true
</code></pre><p>If you want to return the element itself, rather than the result of applying the predicate:</p><pre><code class="klipse-clojure nohighlight">;; predicate returns the value rather than simply true
(some #(if (even? %) %) [1 2 3 4 5])
;; ⇒ 2
</code></pre><p>Since maps can be used as functions, you can use a map as a predicate. This will return the value of the first key in the collection that is also in the map.</p><pre><code class="klipse-clojure nohighlight">(some {:a 1 :b 5} [:h :k :d :b])
;; ⇒ 5
</code></pre><p>Sets can also be used as functions and will return the first item in the collection that is present in the set.</p><pre><code class="klipse-clojure nohighlight">(some #{4} (range 20))
;; ⇒ 4
</code></pre><h3 id="every">every?</h3><p><code>every</code> returns true if the predicate returns true for every item in the collection, otherwise it returns false.</p><pre><code class="klipse-clojure nohighlight">(every? even? (range 0 10 2))
;; ⇒ true
</code></pre><pre><code class="klipse-clojure nohighlight">;; set can be used to see if collection only contains items in the set.
(every? #{2 3 4} [2 3 4 2 3 4])
;; ⇒ true
</code></pre><h3 id="map-mapv">map, mapv</h3><p><code>map</code> is used to sequence of values and generate a new sequence of
values. <code>map</code> produces a lazy sequence. <code>mapv</code> is the same as <code>map</code> but
produces a vector (and is not lazy).</p><p>Essentially, you're creating a <em>mapping</em> from an old sequence of values
to a new sequence of values.</p><pre><code class="klipse-clojure nohighlight">(def numbers
  (range 1 10))
;; ⇒ (1 2 3 4 5 6 7 8 9)
</code></pre><pre><code class="klipse-clojure nohighlight">(map (partial * 2) numbers)
;; ⇒ (2 4 6 8 10 12 14 16 18)
</code></pre><pre><code class="klipse-clojure nohighlight">(mapv (partial * 2) numbers)
;; ⇒ [2 4 6 8 10 12 14 16 18]
</code></pre><pre><code class="klipse-clojure nohighlight">(def scores
  {:clojure 10
   :scala 9
   :jruby 8})

(map #(str "Team " (name (key %)) " has scored " (val %)) scores)
;; ⇒ ("Team scala has scored 9" "Team jruby has scored 8" "Team clojure has scored 10")
</code></pre><h3 id="reduce">reduce</h3><p><code>reduce</code> takes a sequence of values and a function. It applies that
function repeatedly with the sequence of values to <em>reduce</em> it to a
single value.</p><pre><code class="klipse-clojure nohighlight">(def numbers
  (range 1 10))
;; ⇒ (1 2 3 4 5 6 7 8 9)
</code></pre><pre><code class="klipse-clojure nohighlight">(reduce + numbers)
;; ⇒ 45
</code></pre><pre><code class="klipse-clojure nohighlight">(def scores
  {:clojure 10
   :scala 9
   :jruby 8})

(reduce + (vals scores))
;; ⇒ 27
</code></pre><pre><code class="klipse-clojure nohighlight">;; Provide an initial value for the calculation
(reduce + 10 (vals scores))
;; ⇒ 37
</code></pre><h3 id="filter-filterv">filter, filterv</h3><p><code>filter</code> returns a lazy sequence of items that return <code>true</code> for the provided predicate. Contrast to <code>remove</code>.
<code>filterv</code> is the same as <code>filter</code> but produces a vector (and is not lazy).</p><pre><code class="klipse-clojure nohighlight">(filter even? (range 10))
;; ⇒ (0 2 4 6 8)
</code></pre><pre><code class="klipse-clojure nohighlight">(filterv even? (range 10))
;; ⇒ [0 2 4 6 8]
</code></pre><pre><code class="klipse-clojure nohighlight">(filter #(if (&lt; (count %) 5) %) ["Paul" "Celery" "Computer" "Rudd" "Tayne"])
;; ⇒ ("Paul" "Rudd")
</code></pre><p>When using sets with <code>filter</code>, remember that if nil or false is in the set and in the collection, then the predicate will return itself: <code>nil</code>.</p><p>In this example, when nil and false are tested with the predicate, the predicate returns nil. This is because if the item is present in the set it is returned. This will cause that item to /not/ be included in the returned lazy-sequence.</p><pre><code class="klipse-clojure nohighlight">(filter #{:nothing :something nil}
       [:nothing :something :things :someone nil false :pigeons])
;; ⇒ (:nothing :something)
</code></pre><h3 id="remove">remove</h3><p><code>remove</code> returns a lazy sequence of items that return <code>false</code> or <code>nil</code> for the provided predicate. Contrast to <code>filter</code>.</p><pre><code class="klipse-clojure nohighlight">(remove even? (range 10))
;; ⇒ (1 3 5 7 9)
</code></pre><pre><code class="klipse-clojure nohighlight">;; relative complement. probably useless?
(remove {:a 1 :b 2} [:h :k :z :b :s])
;; ⇒ (:h :k :z :s)
</code></pre><p>When using sets with <code>remove</code>, remember that if nil or false is in the set and
in the collection, then the predicate will return that falsey value, and the
item will not be removed -- the item will be included in the returned lazy sequence.</p><p>In this example, when nil and false are tested with the predicate, the predicate
returns falsey. This is because if the item is present in the set it is returned.</p><pre><code class="klipse-clojure nohighlight">(remove #{:nothing :something nil false}
        [:nothing :something :things :someone nil false :pigeons])
;; ⇒ (:things :someone nil false :pigeons)
</code></pre><h3 id="iterate">iterate</h3><p><code>iterate</code> takes a function and an initial value, returns the result of
applying the function on that initial value, then applies the function
again on the resultant value, and repeats forever, lazily. Note that the
function <em>iterates</em> on the value.</p><pre><code class="klipse-clojure nohighlight">(take 5 (iterate inc 1))
;; ⇒ (1 2 3 4 5)
</code></pre><pre><code class="klipse-clojure nohighlight">(defn multiply-by-two
  [value]
  (* 2 value))

(take 10 (iterate multiply-by-two 1))
;; ⇒ (1 2 4 8 16 32 64 128 256 512)
</code></pre><h3 id="get-in">get-in</h3><p><code>get-in</code> is used to <em>get</em> a value that is deep <em>inside</em> a data
structure.</p><p>You have to provide the data structure and a sequence of keys, where a
key is valid at each subsequent level of the nested data structure.</p><p>If the sequence of keys does not lead to a valid path, <code>nil</code> is
returned.</p><pre><code class="klipse-clojure nohighlight">(def family
  {:dad {:shirt 5
         :pants 6
         :shoes 4}
   :mom {:dress {:work 6
                 :casual 7}
         :book 3}
   :son {:toy 5
         :homework 1}})
</code></pre><pre><code class="klipse-clojure nohighlight">(get-in family [:dad :shirt])
;; ⇒ 5
</code></pre><pre><code class="klipse-clojure nohighlight">(get-in family [:mom :dress])
;; ⇒ {:work 6, :casual 7}
</code></pre><pre><code class="klipse-clojure nohighlight">(get-in family [:mom :dress :casual])
;; ⇒ 7
</code></pre><pre><code class="klipse-clojure nohighlight">(get-in family [:son :pants])
;; ⇒ nil

```klipse-clojure
(def locations
  [:office :home :school])

(get-in locations [1])
;; ⇒ :home
</code></pre><h3 id="update-in">update-in</h3><p><code>update-in</code> is used to <em>update</em> a value deep inside a structure
<em>in-place</em>.</p><p>Note that since data structures are immutable, it only returns a
"modified" data structure, it does not actually alter the original
reference.</p><p>The "update" function takes the old value and returns a new value which
<code>update-in</code> uses in the new modified data structure.</p><pre><code class="klipse-clojure nohighlight">(def family
  {:dad {:shirt 5
         :pants 6
         :shoes 4}
   :mom {:dress {:work 6
                 :casual 7}
         :book 3}
   :son {:toy 5
         :homework 1}})
</code></pre><pre><code class="klipse-clojure nohighlight">(update-in family [:dad :pants] inc)

;; ⇒ {:son {:toy 5, :homework 1}, :mom {:dress {:work 6, :casual 7}, :book 3}, :dad {:shoes 4, :shirt 5, :pants 7}}
</code></pre><p>Notice that "pants" gets incremented but the original <code>family</code> data is untouched.</p><pre><code class="klipse-clojure nohighlight">(def locations
  [:office :home :school])

(update-in locations [2] #(keyword (str "high-" (name %))))
;; ⇒ [:office :home :high-school]
</code></pre><p>Again, the original <code>locations</code> data is untouched.</p><h3 id="assoc-in">assoc-in</h3><p><code>assoc-in</code> is used to <em>associate</em> a new value deep inside a structure
<em>in-place</em>.</p><p>Note that since data structures are immutable, it only returns a
"modified" data structure, it does not actually alter the original
reference.</p><p>Note the difference between <code>update-in</code> and <code>assoc-in</code>: <code>update-in</code>
takes a function that applies on the old value to return a new value,
whereas <code>assoc-in</code> takes a new value as-is.</p><pre><code class="klipse-clojure nohighlight">(def family
  {:dad {:shirt 5
         :pants 6
         :shoes 4}
   :mom {:dress {:work 6
                 :casual 7}
         :book 3}
   :son {:toy 5
         :homework 1}})
</code></pre><pre><code class="klipse-clojure nohighlight">(assoc-in family [:son :crayon] 3)
;; ⇒ {:son {:toy 5, :crayon 3, :homework 1}, :mom {:dress {:work 6, :casual 7}, :book 3}, :dad {:shoes 4, :shirt 5, :pants 6}}
</code></pre><p>As with <code>update-in</code>, the original <code>family</code> data is untouched.</p><pre><code class="klipse-clojure nohighlight">(def locations
  [:office :home :school])

(assoc-in locations [3] :high-school)
;; ⇒ [:office :home :school :high-school]
</code></pre><p>Similarly, the original <code>locations</code> data is untouched.</p><h3 id="keys">keys</h3><p><code>keys</code> returns a sequence of the keys in a map or record.</p><pre><code class="klipse-clojure nohighlight">(keys {1 "one" 2 "two" 3 "three"})
;; ⇒ (1 2 3)
</code></pre><pre><code class="klipse-clojure nohighlight">(defrecord Hand [index middle ring pinky thumb])
(keys (Hand. 2 4 3 1 2))
;; ⇒ (:index :middle :ring :pinky :thumb)
</code></pre><h3 id="vals">vals</h3><p><code>vals</code> returns a sequence of vals in a map or record.</p><pre><code class="klipse-clojure nohighlight">(vals {:meows 20 :barks 2 :moos 5})
;; ⇒ (5 2 20)
</code></pre><pre><code class="klipse-clojure nohighlight">(defrecord Hand [index middle ring pinky thumb])
(vals (Hand. 1 2 3 4 5))
;; ⇒ (1 2 3 4 5)
</code></pre><h3 id="select-keys">select-keys</h3><p><code>select-keys</code> is used to extract a subset of a map:</p><pre><code class="klipse-clojure nohighlight">(def family
  {:dad {:shirt 5
         :pant 6
         :shoes 4}
   :mom {:dress {:work 6
                 :casual 7}
         :book 3}
   :son {:toy 5
         :homework 1}})
</code></pre><pre><code class="klipse-clojure nohighlight">(select-keys family [:dad])
;; ⇒ {:dad {:shoes 4, :shirt 5, :pant 6}}
</code></pre><pre><code class="klipse-clojure nohighlight">(select-keys family [:mom :son])
;; ⇒ {:son {:toy 5, :homework 1}, :mom {:dress {:work 6, :casual 7}, :book 3}}
</code></pre><h3 id="take">take</h3><p><code>take</code> returns a lazy sequence of the first <code>n</code> items of a collection <code>coll</code>.</p><pre><code class="klipse-clojure nohighlight">(take 3 [1 3 5 7 9])
;; ⇒ (1 3 5)
</code></pre><pre><code class="klipse-clojure nohighlight">(type (take 3 (range)))
;; ⇒ clojure.lang.LazySeq
</code></pre><p>If there are fewer than <code>n</code> items in <code>coll</code>, all items will be returned.</p><pre><code class="klipse-clojure nohighlight">(take 5 [1 2 3])
;; ⇒ (1 2 3)
</code></pre><pre><code class="klipse-clojure nohighlight">(take 3 nil)
;; ⇒ ()
</code></pre><h3 id="drop">drop</h3><p><code>drop</code> drops <code>n</code> items from a collection <code>coll</code> and returns a lazy sequence of the rest of it.</p><pre><code class="klipse-clojure nohighlight">(drop 3 '(0 1 2 3 4 5 6))
;; ⇒ (3 4 5 6)
</code></pre><pre><code class="klipse-clojure nohighlight">(drop 2 [1 2])
;; ⇒ ()
</code></pre><pre><code class="klipse-clojure nohighlight">(drop 2 nil)
;; ⇒ ()
</code></pre><h3 id="take-while">take-while</h3><p><code>take-while</code> returns a lazy sequence of items from a collection as long
as the predicate returns <code>true</code> for each item:</p><pre><code class="klipse-clojure nohighlight">(take-while #(&lt; % 5) (range))
;; ⇒ (0 1 2 3 4)
</code></pre><h3 id="drop-while">drop-while</h3><p><code>drop-while</code> drops items from a collection as long as the predicate
returns <code>false</code> for the item and when the first non-false item is found,
it returns a lazy sequence from that item onwards:</p><pre><code class="klipse-clojure nohighlight">(drop-while #(&lt; % 5) (range 10))
;; ⇒ (5 6 7 8 9)
</code></pre><h2 id="transducers">Transducers</h2><p>Rich Hickey introduced the <a href="https://clojure.org/news/2014/08/06/transducers-are-coming">concept of transducers</a>
in a mid-2014 blog post, and they arrived in Clojure 1.7. The official
documentation has a good <a href="https://clojure.org/reference/transducers">reference page for transducers</a>.</p><p>The core idea is to separate the transformation function from the input
and output sources, specifying just the transformation itself. This allows
transformations to be composed and reused in a variety of contexts.</p><p>We might write the following code to transform a sequence of numbers:</p><pre><code class="klipse-clojure nohighlight">(-&gt;&gt; (range 10)
     (map inc)
     (filter even?)
     (take 3)
     (into []))
</code></pre><p>At each step, the input is explicitly turned into a sequence and transformed
into a new sequence. The longer the pipeline of transformations, the more
intermediate sequences are created and later thrown away. In the above example,
the final step forces the initial portions of those sequences to be realized.
but up to that point, the transformations are all lazy because the functions
themselves are lazy.</p><p>Many of the sequence and collection functions you've seen in earlier sections
above have an arity that omits the sequence or collection argument, e.g.,
<code>(map inc)</code> instead of <code>(map inc my-seq)</code>. When the sequence or collection
argument is omitted, these calls return a <em>transducer</em> that can be composed
and applied as part of a transformation.</p><p>Transducers allow us to separate the transformation from the input and output:</p><pre><code class="klipse-clojure nohighlight">(def xf (comp (map inc) (filter even?) (take 3)))
(into [] xf (range 10))
</code></pre><p>We can apply this transformation (<code>xf</code>) to any input source and produce
any output -- and no intermediate sequences are created: the composed transformation
is applied directly to the elements from the input to produce the output.</p><h3 id="lazy-or-eager">Lazy or Eager?</h3><p>Transducers may shrink the input (as above) or expand it. Transducers are not
inherently lazy or eager since they are called, as needed, by the process
that applies the transformation to the input to produce the output.</p><p>We've seen eager transformations in the earlier sections above, such as
<code>(into [] my-seq)</code> which is implemented as <code>(reduce conj [] my-seq)</code>
under the hood. In a similar way, <code>(into [] xf my-seq)</code> is equivalent to
<code>(reduce (xf conj) [] my-seq)</code>. Since <code>(reduce (xf f) init my-seq)</code> would
be a common construct when eagerly transforming sequences, Clojure provides
<code>(transduce xf f init my-seq)</code> as a shorthand.</p><pre><code class="klipse-clojure nohighlight">(def xf (comp (map inc) (filter even?) (take 3)))
(transduce xf + 0 (range 10))
</code></pre><p>Whereas <code>(into [] xf (range 10))</code> produces a vector of three numbers,
because it is <code>(transduce xf conj [] (range 10))</code>, we can reuse the transformation
in <code>(transduce xf + 0 (range 10))</code> to produce a single number.</p><p>Clojure also provides <code>(sequence xf my-seq)</code> as a way to get a lazy sequence
of applications of the transformation to the input.</p><p>(note how the transducer is applied to the
reducing function <code>conj</code> to produce a new reducing function).</p><p>Additional reading:</p><ul><li><a href="https://practical.li/blog/posts/transducers-in-clojure-getting-started">Getting Started with Transducers</a> -- <a href="https://practical.li/">Practicalli</a></li><li><a href="https://clojure.org/reference/transducers">Transducers Reference</a> -- <a href="https://clojure.org/">clojure.org</a></li><li><a href="https://clojuredocs.org/clojure.core/transduce">Examples of <code>transduce</code></a> -- <a href="https://clojuredocs.org/">clojuredocs.org</a></li><li><a href="https://clojuredocs.org/clojure.core/sequence">Examples of <code>sequence</code></a> -- <a href="https://clojuredocs.org/">clojuredocs.org</a></li></ul><h2 id="transients">Transients</h2><p>Clojure data structures are immutable, they do not change. Mutating them produces
a new data structure that internally has structural sharing with the original
one. This makes a whole class of concurrency hazards go away but has some
performance penalty and additional GC pressure.</p><p>For cases when raw performance for a piece of code is more important than safety,
Clojure provides mutable versions of vectors and unsorted maps. They are known
as <em>transients</em> and should only be used for locals and as an optimization
technique after profiling.</p><p>Transients are produced from immutable data structures using the <code>clojure.core/transient</code>
function:</p><pre><code class="klipse-clojure nohighlight">(let [m (transient {})
      ;; assoc! returns the updated transient
      m (assoc! m :key "value")]
  (count m))
;; ⇒ 1
</code></pre><p>Operations on a transient may update in place or they may return an updated
collection so you must still bind or reuse their return values, and not rely
on the original transient being updated.</p><p>Note that <code>clojure.core/transient</code> does not affect nested collections, for
example, values in a map of keywords to vectors.</p><p>To mutate transients, use <code>clojure.core/assoc!</code>, <code>clojure.core/dissoc!</code> and
<code>clojure.core/conj!</code>. The exclamation point at the end hints that these
functions work on transients and may modify data structures in place, which
is not safe if transient data structures are shared between threads.</p><p>To create an immutable data structure out of a transient, use <code>clojure.core/persistent!</code>:</p><pre><code class="klipse-clojure nohighlight">(let [m (transient {})
      m (assoc! m :key "value")]
  (persistent! m)) ;; ⇒ {:key "value"}
</code></pre><p>In conclusion: use transients only as an optimization technique and only
after profiling and identifying hot spots in your code. Guessing is the
shortest way we know to blowing the performance.</p><h2 id="custom-collections-and-sequences">Custom Collections and Sequences</h2><p>It is possible to develop custom collection types in Clojure or Java and have
<code>clojure.core</code> functions work on them just like they do on builtin types.</p><p>TBD: <a href="https://github.com/clojure-doc/clojure-doc.github.io#how-to-contribute">How to Contribute</a></p><h2 id="wrapping-up">Wrapping Up</h2><p>When working with Clojure, it is common to operate and transform collections and sequences.
Clojure's core library unify operations on collections and sequences where possible.
This extends to Java collections, arrays and iterable objects for seamless interoperability.</p><p>Most of the time, whenever you need a function that transforms sequences, chances are, there is
one already that does that in <code>clojure.core</code> or you can compose more than one <code>clojure.core</code> function
to achieve the same result.</p><h2 id="contributors">Contributors</h2><p>Michael Klishin <a href="mailto:michael@defprotocol.org">michael@defprotocol.org</a>
Robert Randolph <a href="mailto:audiolabs@gmail.com">audiolabs@gmail.com</a>
satoru <a href="mailto:satorulogic@gmail.com">satorulogic@gmail.com</a></p>

    <div id="prev-next">
        
        <a href="/articles/language/core_overview/">&laquo; Language: clojure.core</a>
        
        
        ||
        
        
        <a href="/articles/language/namespaces/">Language: Namespaces &raquo;</a>
        
    </div>
</div>

            </div>
        </div>

        <div class="col-md-3">
            <div id="sidebar">
                <h3>Links</h3>
                <ul id="links">
                    
                    <li><a href="/articles/about/">About</a></li>
                    
                    <li><a href="/articles/content/">Table of Contents</a></li>
                    
                    <li><a href="/articles/tutorials/getting_started/">Getting Started</a></li>
                    
                    <li><a href="/articles/tutorials/introduction/">Introduction to Clojure</a></li>
                    
                    <li><a href="/articles/tutorials/editors/">Clojure Editors</a></li>
                    
                    <li><a href="/articles/tutorials/basic_web_development/">Basic Web Development</a></li>
                    
                    <li><a href="/articles/language/functions/">Language: Functions</a></li>
                    
                    <li><a href="/articles/language/core_overview/">Language: clojure.core</a></li>
                    
                    <li><a href="/articles/language/collections_and_sequences/">Language: Collections and Sequences</a></li>
                    
                    <li><a href="/articles/language/namespaces/">Language: Namespaces</a></li>
                    
                    <li><a href="/articles/language/interop/">Language: Java Interop</a></li>
                    
                    <li><a href="/articles/language/polymorphism/">Language: Polymorphism</a></li>
                    
                    <li><a href="/articles/language/concurrency_and_parallelism/">Language: Concurrency and Parallelism</a></li>
                    
                    <li><a href="/articles/language/macros/">Language: Macros</a></li>
                    
                    <li><a href="/articles/language/laziness/">Language: Laziness</a></li>
                    
                    <li><a href="/articles/ecosystem/community/">Clojure Community</a></li>
                    
                    <li><a href="/articles/ecosystem/libraries_authoring/">Library Development and Distribution</a></li>
                    
                    <li><a href="/articles/ecosystem/web_development/">Web Development (Overview)</a></li>
                    
                    <li><a href="/articles/cookbooks/cli_build_projects/">Building Projects: tools.build and the Clojure CLI</a></li>
                    
                    <li><a href="/articles/cookbooks/data_structures/">Data Structures</a></li>
                    
                    <li><a href="/articles/cookbooks/strings/">Strings</a></li>
                    
                    <li><a href="/articles/cookbooks/math/">Mathematics with Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/date_and_time/">Date and Time (Help wanted)</a></li>
                    
                    <li><a href="/articles/cookbooks/files_and_directories/">Working with Files and Directories in Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/middleware/">Middleware in Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/parsing_xml_with_zippers/">Parsing XML in Clojure</a></li>
                    
                    <li><a href="/articles/cookbooks/growing_a_dsl_with_clojure/">Growing a DSL with Clojure</a></li>
                    
                </ul>
                
                
            </div>
        </div>
    </div>
    <footer>Copyright &copy; 2023 Multiple Authors
        <p style="text-align: center;">Powered by <a href="https://cryogenweb.org">Cryogen</a></p></footer>
</div>
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js" type="application/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>

 <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<script>
window.klipse_settings = {
  "selector" : ".klipse-clojure"
};
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script> 
</body>
</html>
