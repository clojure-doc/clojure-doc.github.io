<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Clojure Guides: Strings</title>
    

<meta name="description" content="This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.This work is licensed under a Creative Commons
Attribution 3.0 Unported License (including images &amp;
stylesheets). The source is available on
Github.">

<meta property="og:description" content="This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.This work is licensed under a Creative Commons
Attribution 3.0 Unported License (including images &amp;
stylesheets). The source is available on
Github.">

<meta property="og:url" content="https://clojure-doc.github.io/articles/cookbooks/strings/" />
<meta property="og:title" content="Strings" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://clojure-doc.github.io/articles/cookbooks/strings/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Clojure Guides</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li ><a href="/">Home</a></li>
                <li><a href="https://github.com/clojure-doc/clojure-doc.github.io">Contribute</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div><!--/.container-fluid -->
</nav>


<div class="container">


    <div class="row">
        <div class="col-lg-9">
            <div id="content">
                
<div id="custom-page">
    <div id="page-header">
        <h2>Strings</h2>
    </div>
    
    <p>This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.</p><p>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons
Attribution 3.0 Unported License</a> (including images &amp;
stylesheets). The source is available <a href="https://github.com/clojure-doc/clojure-doc.github.io">on
Github</a>.</p><h2 id="overview">Overview</h2><ul><li>Strings are <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">plain Java
strings</a>.
You can use anything which operates on them.</li><li>Java strings are immutable, so they're convenient to use in Clojure.</li><li>You can't add metadata to Java strings.</li><li>Clojure supports some convenient notations:</li></ul><pre><code>    "foo"    java.lang.String
    #"\d"    java.util.regex.Pattern (in this case, one which matches a single digit)
    \f       java.lang.Character (in this case, the letter 'f')
</code></pre><ul><li><strong>Caveat:</strong> Human brains and electronic computers are rather different
devices. So Java strings (sequences of <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#unicode">UTF-16
characters</a>)
don't always map nicely to user-perceived characters. For example, a
single Unicode "code point" doesn't necessarily equal a user-perceived
character. (Like Korean Hangul Jamo, where user-perceived characters
are composed from two or three Unicode code points.) Also, a Unicode
code point may sometimes require 2 UTF-16 characters to encode it.</li></ul><h2 id="preliminaries">Preliminaries</h2><p>Some examples use
<a href="http://clojure.github.io/clojure/clojure.string-api.html">clojure.string</a>,
<a href="https://github.com/edn-format/edn">clojure.edn</a> and
<a href="http://clojure.github.io/clojure/clojure.pprint-api.html">clojure.pprint</a>. We'll
assume your <code>ns</code> macro contains:</p><pre><code class="clojure">(:require [clojure.string :as str]
          [clojure.edn :as edn]
          [clojure.pprint :as pp])
</code></pre><p>or else in the repl you've loaded it:</p><pre><code class="clojure">(require '[clojure.string :as str])
(require '[clojure.edn :as edn])
(require '[clojure.pprint :as pp])
</code></pre><h2 id="recipes">Recipes</h2><h3 id="basics">Basics</h3><pre><code class="clojure">;; Size measurements
(count "0123")      ;=&gt; 4
(empty? "0123")     ;=&gt; false
(empty? "")         ;=&gt; true
(str/blank? "    ") ;=&gt; true

;; Concatenate
(str "foo" "bar")            ;=&gt; "foobar"
(str/join ["0" "1" "2"])     ;=&gt; "012"
(str/join "." ["0" "1" "2"]) ;=&gt; "0.1.2"

;; Matching using plain Java methods.
;;
;; You might prefer regexes for these. For instance, failure returns
;; -1, which you have to test for. And characters like \o are
;; instances of java.lang.Character, which you may have to convert to
;; int or String.
(.indexOf "foo" "oo")         ;=&gt; 1
(.indexOf "foo" "x")          ;=&gt; -1
(.lastIndexOf "foo" (int \o)) ;=&gt; 2

;; Substring
(subs "0123" 1)       ;=&gt; "123"
(subs "0123" 1 3)     ;=&gt; "12"
(str/trim "  foo  ")  ;=&gt; "foo"
(str/triml "  foo  ") ;=&gt; "foo  "
(str/trimr "  foo  ") ;=&gt; "  foo"

;; Multiple substrings
(seq "foo")                       ;=&gt; (\f \o \o)
(str/split "foo/bar/quux" #"/")   ;=&gt; ["foo" "bar" "quux"]
(str/split "foo/bar/quux" #"/" 2) ;=&gt; ["foo" "bar/quux"]
(str/split-lines "foo
bar")                             ;=&gt; ["foo" "bar"]

;; Case
(str/lower-case "fOo") ;=&gt; "foo"
(str/upper-case "fOo") ;=&gt; "FOO"
(str/capitalize "fOo") ;=&gt; "Foo"

;; Escaping
(str/escape "foo|bar|quux" {\| "||"}) ;=&gt; "foo||bar||quux"

;; Get byte array of given encoding.
;; (The output will likely have a different number than "3c3660".)
(.getBytes "foo" "UTF-8") ;=&gt; #&lt;byte[] [B@3c3660&gt;

;; Parsing keywords
(keyword "foo")    ;=&gt; :foo

;; Parsing numbers
(bigint "20000000000000000000000000000") ;=&gt; 20000000000000000000000000000N
(bigdec "20000000000000000000.00000000") ;=&gt; 20000000000000000000.00000000M
(Integer/parseInt "2")                   ;=&gt; 2
(Float/parseFloat "2")                   ;=&gt; 2.0

;; Parsing edn, a subset of Clojure forms.
(edn/read-string "0xffff") ;=&gt; 65535

;; The sledgehammer approach to reading Clojure forms.
;;
;; SECURITY WARNING: Ensure *read-eval* is false when dealing with
;; strings you don't 100% trust. Even though *read-eval* is false by
;; default since Clojure 1.5, be paranoid and set it to false right
;; before you use it, because anything could've re-bound it to true.
(binding [*read-eval* false]
  (read-string "#\"[abc]\""))
;=&gt; #"[abc]"
</code></pre><h3 id="parsing-complex-strings">Parsing complex strings</h3><h4 id="regexes">Regexes</h4><p>Regexes offer a boost in string-matching power. You can express ideas
like repetition, alternatives, etc.</p><p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">Regex
reference.</a></p><p><strong>Groups:</strong> Regex groups are useful, when we want to match more than
one substring. (Or refer to matches later.) In the regex <code>#"(group-1) (group-2)"</code>, the 0th group is the whole match. The 1st group is
started by the left-most <code>(</code>, the 2nd group is started by the
second-left-most <code>(</code>, etc. You can even nest groups. You can refer to
groups later using <code>$0</code>, <code>$1</code>, etc.</p><p><strong>Matching</strong></p><pre><code class="clojure">;; Simple matching
(re-find #"\d+" "foo 123 bar") ;=&gt; "123"

;; What happens when a match fails.
(re-find #"\d+" "foobar") ;=&gt; nil

;; Return only the first groups which satisfy match.
(re-matches #"(@\w+)\s([.0-9]+)%"
            "@shanley 19.8%")
;=&gt;["@shanley 19.8%" "@shanley" "19.8"]

;; Return seq of all matching groups which occur in string.
(re-seq #"(@\w+)\s([.0-9]+)%"
        "@davidgraeber 12.3%,@shanley 19.8%")
;=&gt; (["@davidgraeber 12.3%" "@davidgraeber" "12.3"]
;    ["@shanley 19.8%" "@shanley" "19.8"])
</code></pre><p><strong>Replacing</strong></p><p>We use <code>str/replace</code>. Aside from the first arg (the initial string),
the next two args are match and replacement:</p><pre><code>   match / replacement can be:
     string / string
     char / char
     pattern / (string or function of match).
</code></pre><pre><code class="clojure">;; In the replacement string, $0, $1, etc refer to matched groups.
(str/replace "@davidgraeber 12.3%,@shanley 19.8%"
             #"(@\S+)\s([.0-9]+)%"
             "$2 ($1)")
;=&gt; "12.3 (@davidgraeber),19.8 (@shanley)"

;; Using a function to replace text gives us power.
(println
  (str/replace "@davidgraeber 12.3%,@shanley 19.8%"
               #"(@\w+)\s([.0-9]+)%,?"
               (fn [[_ person percent]]
                   (let [points (-&gt; percent Float/parseFloat (* 100) Math/round)]
                     (str person "'s followers grew " points " points.\n")))))
;print=&gt; @davidgraeber's followers grew 1230 points.
;print=&gt; @shanley's followers grew 1980 points.
;print=&gt;
</code></pre><h4 id="context-free-grammars">Context-free grammars</h4><p>Context-free grammars offer yet another boost in expressive matching
power, compared to regexes. You can express ideas like nesting.</p><p>We'll use <a href="https://github.com/Engelberg/instaparse">Instaparse</a> on
<a href="http://www.json.org/">JSON's grammar</a>.  (This example isn't seriously
tested nor a featureful parser. Use
<a href="https://github.com/clojure/data.json">data.json</a> instead.)</p><pre><code class="clojure">;; Your project.clj should contain this (you may need to restart your JVM):
;;   :dependencies [[instaparse "1.2.4"]]
;;
;;  We'll assume your ns macro contains:
;;   (:require [instaparse.core :as insta])
;; or else in the repl you've loaded it:
;;   (require '[instaparse.core :as insta])

(def barely-tested-json-parser
  (insta/parser
   "object     = &lt;'{'&gt; &lt;w*&gt; (members &lt;w*&gt;)* &lt;'}'&gt;
    &lt;members&gt;  = pair (&lt;w*&gt; &lt;','&gt; &lt;w*&gt; members)*
    &lt;pair&gt;     = string &lt;w*&gt; &lt;':'&gt; &lt;w*&gt; value
    &lt;value&gt;    = string | number | object | array | 'true' | 'false' | 'null'
    array      = &lt;'['&gt; elements* &lt;']'&gt;
    &lt;elements&gt; = value &lt;w*&gt; (&lt;','&gt; &lt;w*&gt; elements)*
    number     = int frac? exp?
    &lt;int&gt;      = '-'? digits
    &lt;frac&gt;     = '.' digits
    &lt;exp&gt;      = e digits
    &lt;e&gt;        = ('e' | 'E') (&lt;'+'&gt; | '-')?
    &lt;digits&gt;   = #'[0-9]+'
    (* First sketched state machine; then it was easier to figure out
       regex syntax and all the maddening escape-backslashes. *)
    string     = &lt;'\\\"'&gt; #'([^\"\\\\]|\\\\.)*' &lt;'\\\"'&gt;
    &lt;w&gt;        = #'\\s+'"))

(barely-tested-json-parser "{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}")
;=&gt; [:object
;     [:string "foo"]
;     [:object
;       [:string "bar"]
;       [:number "99" "." "9" "e" "-" "9"]
;       [:string "quux"]
;       [:array [:number "1"] [:number "2"] [:number "-" "3"]]]]

;; That last output is a bit verbose. Let's process it further.
(-&gt;&gt; (barely-tested-json-parser "{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}")
     (insta/transform {:object hash-map
                       :string str
                       :array vector
                       :number (comp edn/read-string str)}))
;=&gt; {"foo" {"quux" [1 2 -3], "bar" 9.99E-8}}


;; Now we can appreciate what those &lt;angle-brackets&gt; were all about.
;;
;; When to the right of the grammar's =, it totally hides the enclosed
;; thing in the output. For example, we don't care about whitespace,
;; so we hide it with &lt;w*&gt;.
;;
;; When to the left of the grammar's =, it merely prevents a level of
;; nesting in the output. For example, "members" is a rather
;; artificial entity, so we prevent a pointless level of nesting with
;; &lt;members&gt;.
</code></pre><h3 id="building-complex-strings">Building complex strings</h3><h4 id="redirecting-streams">Redirecting streams</h4><p><code>with-out-str</code> provides a simple way to build strings. It redirects
standard output (<code>*out*</code>) to a fresh <code>StringWriter</code>, then returns the
resulting string. So you can use functions like <code>print</code>, <em>even in
nested functions</em>, and get the resulting string at the end.</p><pre><code class="clojure">(let [shrimp-varieties ["shrimp-kabobs" "shrimp creole" "shrimp gumbo"]]
  (with-out-str
    (print "We have ")
    (doseq [name (str/join ", " shrimp-varieties)]
      (print name))
    (print "...")))
;=&gt; "We have shrimp-kabobs, shrimp creole, shrimp gumbo..."
</code></pre><h4 id="format-strings">Format strings</h4><p>Java's templating mini-language helps you build many strings
conveniently. <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">Reference.</a></p><pre><code class="clojure">;; %s is most commonly used to print args. Escape %'s with %%.
(format "%s enjoyed %s%%." "Mozambique" 19.8) ;=&gt; "Mozambique enjoyed 19.8%."

;; The 1$ prefix allows you to keep referring to the first arg.
(format "%1$tY-%1$tm-%1$td" #inst"2000-01-02T00:00:00") ;=&gt; "2000-01-02"

;; Again, 1$, 2$, etc prefixes let us refer to args in arbitrary orders.
(format "New year: %2$tY. Old year: %1$tY"
        #inst"2000-01-02T00:00:00"
        #inst"3111-12-31T00:00:00")
;=&gt; "New year: 3111. Old year: 2000"
</code></pre><h4 id="cl-format">CL-Format</h4><p><code>cl-format</code> is a port of Common Lisp's notorious, powerful string
formatting mini-language. For example, you can build strings from
sequences. (As well as oddities like print numbers in English or two
varieties of Roman numerals.) However, it's weaker than plain <code>format</code>
with printing dates and referring to args in arbitrary order.</p><p>Remember that <code>cl-format</code> represents a (potentially unreadable)
language which your audience didn't sign up to learn. If you're the
sort of person who likes it, try to only use it in sweetspots where it
provides clarity for little complexity.</p><p><a href="http://www.gigamonkeys.com/book/a-few-format-recipes.html">Tutorial</a>
in Practical Common
Lisp. <a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">Reference</a>
in Common Lisp's Hyperspec.</p><pre><code class="clojure">;; The first param prints to *out* if true. To string if false.
;; To a stream if it's a stream.
(pp/cl-format true "栳疱蜚孱翎珏痫轭酤吼^%}"
              {"@davidgraeber" 12.3
               "@shanley" 19.8
               "@tjgabbour" 1})
;print=&gt; @davidgraeber had 12.3 percentage points.
;print=&gt; @tjgabbour had 1 percentage point.
;print=&gt; @shanley had 19.8 percentage points.

(def format-string "［箕狺箕犷狺夯利狺［滑犷夯蔺蔺痧沆骘蝽狒铋骘蝽狒篝蜷铉圯唤玺痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⑤唤玺⒗箬犷戾痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⒗溽鲩溏蜥邂弪⑤唤玺⒗箬犷戾犷冷狯殇珧徨忮颌痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⒗溽鲩溏蜥邂弪⒗筢蜥桦孱潸轱颌荸唤玺⒗箬犷戾冷狯殇珧徨忮颥犷荔狎徼脲钿轱颌集泔溴炯痱寰艰殇舰泔铘蜷怩麸蝮⒕蔑铘蜷怩麸蝮集璨炯鹁躁轻忖秕坚栩彐舰磲殪麸呼赙荔轫痨弼犰蹂溴⒕絷缋箝眇戾鲠祯瀹溴集峋舶背矧殓轭犰狨翳矧┘鹁间轹殇舰痱弼铄簪坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翎唧趄蹉趱蝈蟑⒕灬聃锘尼翎郁蝓泗躜弩ㄈ屐麽铘邃┘峋坚栩彐舰狎糸沆弩泔镫怙镫蟑磲翳⒕歪翳屙狒殂鏖翳渺镪躜蜥聃锘集峋集溟鼍集溟鼍集溟鼍集溟鼍间轹沆狍蠼泔飙礓尝间轹殇舰箝溴忉颌艰尘涕铍蠹璩减殇舰扉铍螈检榫坚栩彐舰狎糸沆弩徕秕舣⒕菱秕艏峋集扉检榫坚栩彐舰狎糸沆弩泔铘孱舣⒕葬忪镦蔑铘孱趔集峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑珏趑轭邕篝狎翦浏⒕清趑轭郁狎翦鏖翳渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑轭趄镤蹉糸镱⒕深趄镤蹉糸镱麸渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑屙徙蟑⒕渺镪躜鏖翳彭徙蠹峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑鲩磉骈蝈痨徙瀵⒕渺镪躜鏖翳珠犷骈蝈痨徙瀹鲩砑峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑邈扉痼瀵⒕郁狎糸铉鏖翳陪扉痼犷蔑躅翦蜚祜汶鏖箦骑渺镪躜腻鲥祜痦孱艏峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑忉箝氵麇膺溴鲥祜痦孱舣⒕箩箝族腻鲥祜痦孱艏峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑疳蝮轭邕盱喵轸柽轲疱蝮⒕嗅蝮轭赝轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑珧秣轭邕徇潴爝鏖翳咩祜牾蝈⒕球秣轭挠鏖翳渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔蝈唢鲥蝣殄鳢⒕霄弪鲩鬻镦沆镪躜瀹泔蝈翳篝犷溽蜾渺镪躜扉怛狎集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏钺礤箴徙弩⒕渺镪躜吾礤箴徙弩犷轴蝮集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔祆邈糸镱筮犷溥箦聃孱沐蟑⒕蔑祆邈糸镱犷渝聃孱沐轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏骢钽糸镱蟑⒕契钽糸镱轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏灬轭弩蟑⒕提轭弩轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏轭翦蝻鸠⒕渺镪躜轭翦蝻疱蜥忾扉豉鏖翳梳鲠集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏磲泸矬⒕渺镪躜歪泸矬犷湾翎痱镧蜥眄轭缂峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏痫禊盹蝠栝箜⒕酗禊盹蝠栝箜轭渺镪躜搴序雉镢镬犷王祠轫弭栾潴集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔钽躜蝈钽哚钿唣狎犰戾扉箜⒕蔑钽躜蝈钽犷嗅蜥祆屐轶轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏珈矬筢蝙⒕渺镪躜藻蝽轭镬镧酋殇寮峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙扉怛狎殄筮溟蝈泗矧⒕拈蝈泗矧镦渺镪躜涕怛狎殄蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙扉怛狎殄筮狨翳矧轭绡⒕涕怛狎腻鲥祜痦孱犷拈篝蜷怩糸镱集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙珏铄蜥糸铉咪镢蹴孱翎糸镱⒕清铄蜥糸铉娘沲礤铘狒轱罴峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙溽翎唣蝻沐篌轭绡⒕尼翎序镢弩箝铉ㄈ屐揍铘邃┘峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙麇膺溴鲥祜痦孱舣⒕族腻鲥祜痦孱ㄏ鲥蝣殄鳗集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙赆鲠哧溻惘栾礤⒕赆鲠赇忏清趑轭郁狎翦浼峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙赆鲠哧溻惘躞轭邕篑殳⒕赆鲠赇忏歪铋瘐灬糸铉溽翎鏖翳友碳峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙赆鲠哧溻惘躞轭邕滗殳⒕赆鲠赇忏阵轭哪犷湾翎溽翎集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙赆鲠哧溻惘蝈躞轭邕泔铑邈糸镱蟑⒕赆鲠赇忏蕊麸蝈躞溽翎忉箦泔铑邈糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏痫禊哝畀⒕泔蝈豉疱酗禊盹蝠栝契钽糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏骢钽糸镱唪疱蟑⒕泔蝈豉疱契钽糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏篝狎舣轭趄镤蹉糸镱哚钿唔雉轹狒轱畀⒕泔蝈豉疱清趑轭郁狎翦浜深趄镤蹉糸镱犷惋糸鲠糸镱集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏篝狎舣犷铒翎糸镱蟑⒕泔蝈豉疱令铒翎糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏聃殂脒珲殇瀵⒕泔蝈豉疱氧殂酋殇寮峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏骈祠弪蟑⒕泔蝈豉疱崎祠弪蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏扉黹翎糸镱蟑⒕泔蝈豉疱涕黹翎糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏栾礤⒕泔蝈豉疱阵弪娘沲礤铘狒轱蕊礤集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏蜥糸镱犰瀵⒕泔蝈豉疱裔糸镱犰寮峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏祜镳蟑⒕泔蝈豉疱田镳轭泔铙趄蹉趔集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏眄唣蝻麸泔爝溽翎豉疱蟑⒕泔蝈豉疱序雉镢镬蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏躞弪咪镢蹴孱翎糸镱⒕泔蝈豉疱阵弪娘沲礤铘狒轱罴峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔蝈唪疱浏豉疱蟑⒕泔蝈豉疱赠疱蠹峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙磲鲥畀⒕蕊麸躞歪鲥麸怩殪渺镪躜痱镪邈趔集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔眄躅轸⒕渺镪躜蔑眄躅轸集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙躞弪哏蝻躔蟑⒕渺镪躜阵弪球秕痼集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙蝓铑轭邕沆牾绡⒕阴铑轭渺镪躜阵弪球秕鸺峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙怙镫蟑⒕嘛镫徕秕渺镪躜犷渺镪躜逵泸轲艏峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翎唧趄蹉趱蝈蟑⒕尼翎郁蝓泗躜弩ㄈ屐麽铘邃┘峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑篝蜷铉蟑⒕郁蜷铉蠹峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑磲翳⒕歪翳屙狒殂鏖翳渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翦哚钿唪轫瀵⒕尼翦犷蚤礤ㄈ屐麽铘邃┘峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑骈戾筮犷溥溟蝈泗矧殄蟑⒕罪螂轭鏖翳崎戾犷拈蝈泗矧殄轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑黹滗戾麽蝈⒕烷滗戾麽蝈轭渺镪躜寮峋集扉集蹯集溟鼍集溟鼍集溟鼍兼镲翦蚓蔑瘗蜷玷泔瘗舶脖王祠轲戾刘翳矧拣篝戾舰翦舡犰殓詈沐铘弪虎拘秣弪邃怡坚栩彐舰梏麴函泸镧孱麇猱矧纰久蝙镧孱集峋集鹁集骘雉弪集溟鼍俭泸轲篁憬泔溴犟蹂蝙泔懑犟蹂蝙碑北爱黹町牦⒕集筱蜷痿俭泸轲篁憬磲沅町怙雉篝蜥疸漕泔懑怙雉篝蜥鸠钞钞隘牦怙雉篝蜥甬黹町牦⒕集筱蜷痿俭泸轲篁憬牦栝玷扉玷舢疳汶牦豉疱舰狃痨殂狒轱畀赆鲠筱蜷痿⒕集筱蜷痿俭泸轲艟桁牦轭轸乳玷扉玷糸铉项田徜ī患筱蜷痿集怙澌集梏盱