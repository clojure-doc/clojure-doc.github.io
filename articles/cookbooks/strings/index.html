<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Clojure Guides: Strings</title>
    

<meta name="description" content="This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.This work is licensed under a Creative Commons
Attribution 3.0 Unported License (including images &amp;
stylesheets). The source is available on
Github.">

<meta property="og:description" content="This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.This work is licensed under a Creative Commons
Attribution 3.0 Unported License (including images &amp;
stylesheets). The source is available on
Github.">

<meta property="og:url" content="https://clojure-doc.org/articles/cookbooks/strings/" />
<meta property="og:title" content="Strings" />
<meta property="og:type" content="article" />

    <link rel="canonical" href="https://clojure-doc.org/articles/cookbooks/strings/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700" rel="stylesheet"
          type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Clojure Guides</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li ><a href="/">Home</a></li>
                <li><a href="https://github.com/clojure-doc/clojure-doc.github.io">Contribute</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div><!--/.container-fluid -->
</nav>


<div class="container">


    <div class="row">
        <div class="col-lg-9">
            <div id="content">
                
<div id="custom-page">
    <div id="page-header">
        <h2>Strings</h2>
    </div>
    
    <p>This cookbook covers working with strings in Clojure using built-in
functions, standard and contrib libraries, and parts of the JDK via
interoperability.</p><p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/3.0/">Creative Commons
Attribution 3.0 Unported License</a> (including images &amp;
stylesheets). The source is available <a href="https://github.com/clojure-doc/clojure-doc.github.io">on
Github</a>.</p><h2 id="overview">Overview</h2><ul><li>Strings are <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">plain Java
strings</a>.
You can use anything which operates on them.</li><li>Java strings are immutable, so they're convenient to use in Clojure.</li><li>You can't add metadata to Java strings.</li><li>Clojure supports some convenient notations:</li></ul><pre><code>    "foo"    java.lang.String
    #"\d"    java.util.regex.Pattern (in this case, one which matches a single digit)
    \f       java.lang.Character (in this case, the letter 'f')
</code></pre><ul><li><strong>Caveat:</strong> Human brains and electronic computers are rather different
devices. So Java strings (sequences of <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#unicode">UTF-16
characters</a>)
don't always map nicely to user-perceived characters. For example, a
single Unicode "code point" doesn't necessarily equal a user-perceived
character. (Like Korean Hangul Jamo, where user-perceived characters
are composed from two or three Unicode code points.) Also, a Unicode
code point may sometimes require 2 UTF-16 characters to encode it.</li></ul><h2 id="preliminaries">Preliminaries</h2><p>Some examples use
<a href="https://clojure.github.io/clojure/clojure.string-api.html">clojure.string</a>,
<a href="https://github.com/edn-format/edn">clojure.edn</a> and
<a href="https://clojure.github.io/clojure/clojure.pprint-api.html">clojure.pprint</a>. We'll
assume your <code>ns</code> macro contains:</p><pre><code class="clojure">(:require [clojure.string :as str]
          [clojure.edn :as edn]
          [clojure.pprint :as pp])
</code></pre><p>or else in the repl you've loaded it:</p><pre><code class="clojure">(require '[clojure.string :as str])
(require '[clojure.edn :as edn])
(require '[clojure.pprint :as pp])
</code></pre><h2 id="recipes">Recipes</h2><h3 id="basics">Basics</h3><pre><code class="clojure">;; Size measurements
(count "0123")      ;=&gt; 4
(empty? "0123")     ;=&gt; false
(empty? "")         ;=&gt; true
(str/blank? "    ") ;=&gt; true

;; Concatenate
(str "foo" "bar")            ;=&gt; "foobar"
(str/join ["0" "1" "2"])     ;=&gt; "012"
(str/join "." ["0" "1" "2"]) ;=&gt; "0.1.2"

;; Matching using plain Java methods.
;;
;; You might prefer regexes for these. For instance, failure returns
;; -1, which you have to test for. And characters like \o are
;; instances of java.lang.Character, which you may have to convert to
;; int or String.
(.indexOf "foo" "oo")         ;=&gt; 1
(.indexOf "foo" "x")          ;=&gt; -1
(.lastIndexOf "foo" (int \o)) ;=&gt; 2

;; Substring
(subs "0123" 1)       ;=&gt; "123"
(subs "0123" 1 3)     ;=&gt; "12"
(str/trim "  foo  ")  ;=&gt; "foo"
(str/triml "  foo  ") ;=&gt; "foo  "
(str/trimr "  foo  ") ;=&gt; "  foo"

;; Multiple substrings
(seq "foo")                       ;=&gt; (\f \o \o)
(str/split "foo/bar/quux" #"/")   ;=&gt; ["foo" "bar" "quux"]
(str/split "foo/bar/quux" #"/" 2) ;=&gt; ["foo" "bar/quux"]
(str/split-lines "foo
bar")                             ;=&gt; ["foo" "bar"]

;; Case
(str/lower-case "fOo") ;=&gt; "foo"
(str/upper-case "fOo") ;=&gt; "FOO"
(str/capitalize "fOo") ;=&gt; "Foo"

;; Escaping
(str/escape "foo|bar|quux" {\| "||"}) ;=&gt; "foo||bar||quux"

;; Get byte array of given encoding.
;; (The output will likely have a different number than "3c3660".)
(.getBytes "foo" "UTF-8") ;=&gt; #object["[B" 0x39666e42 "[B@39666e42"]

;; Parsing keywords
(keyword "foo")    ;=&gt; :foo

;; Parsing numbers
(bigint "20000000000000000000000000000") ;=&gt; 20000000000000000000000000000N
(bigdec "20000000000000000000.00000000") ;=&gt; 20000000000000000000.00000000M
(Integer/parseInt "2")                   ;=&gt; 2
(Float/parseFloat "2")                   ;=&gt; 2.0

;; Parsing edn, a subset of Clojure forms.
(edn/read-string "0xffff") ;=&gt; 65535

;; The sledgehammer approach to reading Clojure forms.
;;
;; SECURITY WARNING: Ensure *read-eval* is false when dealing with
;; strings you don't 100% trust. Even though *read-eval* is false by
;; default since Clojure 1.5, be paranoid and set it to false right
;; before you use it, because anything could've re-bound it to true.
(binding [*read-eval* false]
  (read-string "#\"[abc]\""))
;=&gt; #"[abc]"
</code></pre><h3 id="parsing-complex-strings">Parsing complex strings</h3><h4 id="regexes">Regexes</h4><p>Regexes offer a boost in string-matching power. You can express ideas
like repetition, alternatives, etc.</p><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">Regex
reference.</a></p><p><strong>Groups:</strong> Regex groups are useful, when we want to match more than
one substring. (Or refer to matches later.) In the regex <code>#"(group-1) (group-2)"</code>, the 0th group is the whole match. The 1st group is
started by the left-most <code>(</code>, the 2nd group is started by the
second-left-most <code>(</code>, etc. You can even nest groups. You can refer to
groups later using <code>$0</code>, <code>$1</code>, etc.</p><p><strong>Matching</strong></p><pre><code class="clojure">;; Simple matching
(re-find #"\d+" "foo 123 bar") ;=&gt; "123"

;; What happens when a match fails.
(re-find #"\d+" "foobar") ;=&gt; nil

;; Return only the first groups which satisfy match.
(re-matches #"(@\w+)\s([.0-9]+)%"
            "@shanley 19.8%")
;=&gt;["@shanley 19.8%" "@shanley" "19.8"]

;; Return seq of all matching groups which occur in string.
(re-seq #"(@\w+)\s([.0-9]+)%"
        "@davidgraeber 12.3%,@shanley 19.8%")
;=&gt; (["@davidgraeber 12.3%" "@davidgraeber" "12.3"]
;    ["@shanley 19.8%" "@shanley" "19.8"])
</code></pre><p><strong>Replacing</strong></p><p>We use <code>str/replace</code>. Aside from the first arg (the initial string),
the next two args are match and replacement:</p><pre><code>   match / replacement can be:
     string / string
     char / char
     pattern / (string or function of match).
</code></pre><pre><code class="clojure">;; In the replacement string, $0, $1, etc refer to matched groups.
(str/replace "@davidgraeber 12.3%,@shanley 19.8%"
             #"(@\S+)\s([.0-9]+)%"
             "$2 ($1)")
;=&gt; "12.3 (@davidgraeber),19.8 (@shanley)"

;; Using a function to replace text gives us power.
(println
  (str/replace "@davidgraeber 12.3%,@shanley 19.8%"
               #"(@\w+)\s([.0-9]+)%,?"
               (fn [[_ person percent]]
                   (let [points (-&gt; percent Float/parseFloat (* 100) Math/round)]
                     (str person "'s followers grew " points " points.\n")))))
;print=&gt; @davidgraeber's followers grew 1230 points.
;print=&gt; @shanley's followers grew 1980 points.
;print=&gt;
</code></pre><h4 id="context-free-grammars">Context-free grammars</h4><p>Context-free grammars offer yet another boost in expressive matching
power, compared to regexes. You can express ideas like nesting.</p><p>We'll use <a href="https://github.com/Engelberg/instaparse">Instaparse</a> on
<a href="https://www.json.org/">JSON's grammar</a>.  (This example isn't seriously
tested nor a featureful parser. Use
<a href="https://github.com/clojure/data.json">data.json</a> instead.)</p><pre><code class="clojure">;; Your project.clj should contain this (you may need to restart your JVM):
;;   :dependencies [[instaparse "1.2.4"]]
;;
;;  We'll assume your ns macro contains:
;;   (:require [instaparse.core :as insta])
;; or else in the repl you've loaded it:
;;   (require '[instaparse.core :as insta])

(def barely-tested-json-parser
  (insta/parser
   "object     = &lt;'{'&gt; &lt;w*&gt; (members &lt;w*&gt;)* &lt;'}'&gt;
    &lt;members&gt;  = pair (&lt;w*&gt; &lt;','&gt; &lt;w*&gt; members)*
    &lt;pair&gt;     = string &lt;w*&gt; &lt;':'&gt; &lt;w*&gt; value
    &lt;value&gt;    = string | number | object | array | 'true' | 'false' | 'null'
    array      = &lt;'['&gt; elements* &lt;']'&gt;
    &lt;elements&gt; = value &lt;w*&gt; (&lt;','&gt; &lt;w*&gt; elements)*
    number     = int frac? exp?
    &lt;int&gt;      = '-'? digits
    &lt;frac&gt;     = '.' digits
    &lt;exp&gt;      = e digits
    &lt;e&gt;        = ('e' | 'E') (&lt;'+'&gt; | '-')?
    &lt;digits&gt;   = #'[0-9]+'
    (* First sketched state machine; then it was easier to figure out
       regex syntax and all the maddening escape-backslashes. *)
    string     = &lt;'\\\"'&gt; #'([^\"\\\\]|\\\\.)*' &lt;'\\\"'&gt;
    &lt;w&gt;        = #'\\s+'"))

(barely-tested-json-parser "{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}")
;=&gt; [:object
;     [:string "foo"]
;     [:object
;       [:string "bar"]
;       [:number "99" "." "9" "e" "-" "9"]
;       [:string "quux"]
;       [:array [:number "1"] [:number "2"] [:number "-" "3"]]]]

;; That last output is a bit verbose. Let's process it further.
(-&gt;&gt; (barely-tested-json-parser "{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}")
     (insta/transform {:object hash-map
                       :string str
                       :array vector
                       :number (comp edn/read-string str)}))
;=&gt; {"foo" {"quux" [1 2 -3], "bar" 9.99E-8}}


;; Now we can appreciate what those &lt;angle-brackets&gt; were all about.
;;
;; When to the right of the grammar's =, it totally hides the enclosed
;; thing in the output. For example, we don't care about whitespace,
;; so we hide it with &lt;w*&gt;.
;;
;; When to the left of the grammar's =, it merely prevents a level of
;; nesting in the output. For example, "members" is a rather
;; artificial entity, so we prevent a pointless level of nesting with
;; &lt;members&gt;.
</code></pre><h3 id="building-complex-strings">Building complex strings</h3><h4 id="redirecting-streams">Redirecting streams</h4><p><code>with-out-str</code> provides a simple way to build strings. It redirects
standard output (<code>*out*</code>) to a fresh <code>StringWriter</code>, then returns the
resulting string. So you can use functions like <code>print</code>, <em>even in
nested functions</em>, and get the resulting string at the end.</p><pre><code class="clojure">(let [shrimp-varieties ["shrimp-kabobs" "shrimp creole" "shrimp gumbo"]]
  (with-out-str
    (print "We have ")
    (let [names (str/join ", " shrimp-varieties)]
      (print names))
    (print "...")))
;=&gt; "We have shrimp-kabobs, shrimp creole, shrimp gumbo..."
</code></pre><h4 id="format-strings">Format strings</h4><p>Java's templating mini-language helps you build many strings
conveniently. <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">Reference.</a></p><pre><code class="clojure">;; %s is most commonly used to print args. Escape %'s with %%.
(format "%s enjoyed %s%%." "Mozambique" 19.8) ;=&gt; "Mozambique enjoyed 19.8%."

;; The 1$ prefix allows you to keep referring to the first arg.
(format "%1$tY-%1$tm-%1$td" #inst"2000-01-02T00:00:00") ;=&gt; "2000-01-02"

;; Again, 1$, 2$, etc prefixes let us refer to args in arbitrary orders.
(format "New year: %2$tY. Old year: %1$tY"
        #inst"2000-01-02T00:00:00"
        #inst"3111-12-31T00:00:00")
;=&gt; "New year: 3111. Old year: 2000"
</code></pre><h4 id="cl-format">CL-Format</h4><p><code>cl-format</code> is a port of Common Lisp's notorious, powerful string
formatting mini-language. For example, you can build strings from
sequences. (As well as oddities like print numbers in English or two
varieties of Roman numerals.) However, it's weaker than plain <code>format</code>
with printing dates and referring to args in arbitrary order.</p><p>Remember that <code>cl-format</code> represents a (potentially unreadable)
language which your audience didn't sign up to learn. If you're the
sort of person who likes it, try to only use it in sweetspots where it
provides clarity for little complexity.</p><p><a href="https://www.gigamonkeys.com/book/a-few-format-recipes.html">Tutorial</a>
in Practical Common
Lisp. <a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">Reference</a>
in Common Lisp's Hyperspec.</p><pre><code class="clojure">;; The first param prints to *out* if true. To string if false.
;; To a stream if it's a stream.
(pp/cl-format true "栳疱蜚孱翎珏痫轭酤吼^%}"
              {"@davidgraeber" 12.3
               "@shanley" 19.8
               "@tjgabbour" 1})
;print=&gt; @davidgraeber had 12.3 percentage points.
;print=&gt; @tjgabbour had 1 percentage point.
;print=&gt; @shanley had 19.8 percentage points.

(def format-string "［箕狺箕犷狺夯利狺［滑犷夯蔺蔺痧沆骘蝽狒铋骘蝽狒篝蜷铉圯唤玺痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⑤唤玺⒗箬犷戾痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⒗溽鲩溏蜥邂弪⑤唤玺⒗箬犷戾犷冷狯殇珧徨忮颌痧沆骘蝽狒铋骘蝽狒篝蜷铉邰荔栳铎妁⒗溽鲩溏蜥邂弪⒗筢蜥桦孱潸轱颌荸唤玺⒗箬犷戾冷狯殇珧徨忮颥犷荔狎徼脲钿轱颌集泔溴炯痱寰艰殇舰泔铘蜷怩麸蝮⒕蔑铘蜷怩麸蝮集璨炯鹁躁轻忖秕坚栩彐舰磲殪麸呼赙荔轫痨弼犰蹂溴⒕絷缋箝眇戾鲠祯瀹溴集峋舶背矧殓轭犰狨翳矧┘鹁间轹殇舰痱弼铄簪坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翎唧趄蹉趱蝈蟑⒕灬聃锘尼翎郁蝓泗躜弩集峋坚栩彐舰狎糸沆弩泔镫怙镫蟑磲翳⒕歪翳屙狒殂鏖翳渺镪躜蜥聃锘集峋集溟鼍集溟鼍集溟鼍集溟鼍间轹沆狍蠼泔飙礓尝间轹殇舰箝溴忉颌艰尘涕铍蠹璩减殇舰扉铍螈检榫坚栩彐舰狎糸沆弩徕秕舣⒕菱秕艏峋集扉检榫坚栩彐舰狎糸沆弩泔铘孱舣⒕葬忪镦蔑铘孱趔集峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑珏趑轭邕篝狎翦浏⒕清趑轭郁狎翦浼峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑轭趄镤蹉糸镱⒕深趄镤蹉糸镱麸渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑邃轸矧蟑⒕渺镪躜配轸矧蠹峋集扉检榫坚栩彐舰狎糸沆弩趱麸蜷犰蟑忉箝氵麇膺溴鲥祜痦孱舣⒕箩箝族腻鲥祜痦孱艏峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏骢钽糸镱蟑⒕提铉踽珏契钽糸镱蠹峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔蝈唢鲥蝣殄鳢⒕提铉踽珏沆镪躜瀹泔蝈集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔祆邈糸镱筮犷溥箦聃孱沐蟑⒕提铉踽珏蔑祆邈糸镱犷渝聃孱沐蠹峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏钺礤箴徙弩⒕提铉踽珏吾礤箴徙弩集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏轭翦蝻鸠⒕提铉踽珏梳鲠深翦蝻鸺峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏痫禊盹蝠栝箜⒕提铉踽珏酗禊盹蝠栝箜集峋集扉检榫坚栩彐舰狎糸沆弩灬铉踽珏泔钽躜蝈钽哚钿唣狎犰戾扉箜⒕提铉踽珏蔑钽躜蝈钽犷嗅蜥祆屐轶砑峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙泔眄躅轸⒕渺镪躜蔑眄躅轸集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙扉怛狎殄筮狨翳矧轭绡⒕涕怛狎腻鲥祜痦孱犷拈篝蜷怩糸镱集峋集扉检榫坚栩彐舰狎糸沆弩邈矬篝屙麇膺溴鲥祜痦孱舣⒕族腻鲥祜痦孱ㄏ鲥蝣殄鳗集峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑沆檫怩殪溥痱镪邈趔⒕迈殪溟铉序镪邈趔麸镬螽怩殪犷翳渺镪躜锰杉峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翎唧趄蹉趱蝈蟑⒕尼翎郁蝓泗躜弩集峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑篝蜷铉蟑⒕郁蜷铉蠹峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑磲翳⒕歪翳屙狒殂鏖翳渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑溽翦哚钿唪轫瀵⒕尼翦犷蚤礤ㄈ屐麽铘邃┘峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑骈戾筮犷溥溟蝈泗矧殄蟑⒕罪螂轭鏖翳崎戾犷拈蝈泗矧殄轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑黹滗戾麽蝈⒕烷滗戾麽蝈轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑疳蝮轭邕盱喵轸柽轲疱蝮⒕嗅蝮轭赝轭渺镪躜寮峋集扉检榫坚栩彐舰狎糸沆弩泔镫怙镫蟑珧秣轭邕徇潴爝鏖翳咩祜牾蝈⒕球秣轭挠鏖翳渺镪躜寮峋集扉集蹯集溟鼍集溟鼍集溟鼍兼镲翦蚓蔑瘗蜷玷泔瘗舶渤王祠轲戾刘翳矧拣篝戾舰翦舡犰殓詈沐铘弪虎拘秣弪邃怡坚栩彐舰梏麴蠛泸镧孱麇猱矧纰久蝙镧孱集峋集鹁集骘雉弪集溟鼍俭泸轲篁憬泔溴犟蹂蝙泔懑犟蹂蝙碑辈串黹町牦⒕集筱蜷痿俭泸轲篁憬磲沅町怙雉篝蜥疸漕泔懑怙雉篝蜥鸠钞钞隘牦怙雉篝蜥甬黹町牦⒕集筱蜷痿俭泸轲篁憬牦栝玷扉玷舢疳汶牦豉疱舰狃痨殂狒轱畀赆鲠筱蜷痿⒕集筱蜷痿俭泸轲艟桁牦轭轸乳玷扉玷糸铉项田徜ī患筱蜷痿集怙澌集梏盱